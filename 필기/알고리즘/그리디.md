# 그리디

## 1. 반복과 재귀

- **개념**

> - 반복과 재귀는 유사한 작업을 수행할 수 있다.
> - 반복은 수행하는 작업이 완료될 때 까지 계속 반복
>   - 루프 (for, while 구조)
> - 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
>   - 하나의 큰 문제를 해결할 수 있는 (해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.

- **반복 구조**

> - **초기화**
>   - 반복되는 명령문을 실행하기 전에 조건 검사에 사용할 변수의 초기 값 설정
> - **조건 검사**
> - **반복할 명령문 실행**
> - **업데이트**
>   - 무한 루프가 되지 않게 조건이 거짓이 되게 한다.

- **재귀적 알고리즘**

> - 재귀적 정의는 두 부분으로 나뉜다.
> - 하나 또는 그 이상의 기본 경우 (basis case or rule)
>   - 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드(seed) 역할
> - 하나 또는 그 이상의 유도된 경우 (inductive case or rule)
>   - 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

- **재귀 함수**

> - 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
> - 기본 부분 (basis part)와 유도 부분 (inductive part)로 구성된다.
> - 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉽다.
>   - 그러나, 재귀에 대해 익숙하지 않은 개발자들은 재귀적 프로그램이 어렵다고 느낀다.
> - 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀 호출은 반복 적인 스택의 사용을 의미하며 메모리 및 속도에서 성능 저하가 발생한다.

- **재귀 vs 반복**

> - 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
> - 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다.
>   - 추상 자료형(List, tree)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많다.
> - 일반적으로 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 한다.
> - **입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.**

---

## 2. 완전 검색 기법

- **개념**

> - 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
>   - 완전 검색은 입력의 크기를 작게 해서 간편하고 빠르게 답을 구하는 프로그램을 작성한다.
> - 이를 기반으로 그리디 기법이나 동적 계획 법을 이용해서 효율적인 알고리즘을 찾을 수 있다.
> - 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것

---

## 3. 순열

- **개념**

> - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
> - **서로 다른 n개 중 r개를 택하는 순열**
>   - **nPr = n * (n-1) * (n-2) * (n-3) * ...*(n-r+1)**
> - **nPn = n!이라고 표기**
> - 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다.
>   - ex) TSP (Traveling Salesman Problem)
> - N 개의 요소들에 대해서 n! 개의 순열들이 존재한다.

- **재귀 이용한 순열 생성**

> ```python
> # 자리를 바꿔서 출력하는 방식
> def f(i,k):
>     if i == k:
>         print(p)
>     else:
>         for j in range(i,k):
>             p[i],p[j] = p[j], p[i]
>             f(i+1,k)
>             p[i],p[j] = p[j],p[i]
> 
> 
> p = [1,2,3]
> f(0,3)
> ```
> 
> ```python
> # 반복문을 이용한 순열
> for i in range(1,4):
>     for j in range(1,4):
>         if i != j:
>             for k in range(1,4):
>                 if k != i and k != j:
>                     print(i,j,k)
> ```
> 
> ```python
> # 값을 저장해서 출력하는 방식
> def f(i,k):
>     if i == k:
>         print(p)
>     else:
>         for j  in range(k):
>             if not used[j]:         # a[j]가 아직 사용되지 않았으면
>                 used[j] = 1         # a[j] 사용됨으로 표시
>                 p[i] = a[j]         # p[i]는 a[j]로 결정
>                 f(i+1,k)            # p[i+1] 값을 결정하러 이동
>                 used[j] = 0         # a[j]를 다른 자리에서 쓸 수 있도록 해제
> 
> N = 3
> a = [i for i in range(1,N+1)]
> used = [0] * N
> p = [0] * N
> f(0,N)
> ```
> 
> ```python
> # N개 중에 R개만 뽑는 순열
> def f(i,k, r):
>     if i == r:
>         print(p)
>     else:
>         for j  in range(k):
>             if not used[j]:         # a[j]가 아직 사용되지 않았으면
>                 used[j] = 1         # a[j] 사용됨으로 표시
>                 p[i] = a[j]         # p[i]는 a[j]로 결정
>                 f(i+1,k,r)            # p[i+1] 값을 결정하러 이동
>                 used[j] = 0         # a[j]를 다른 자리에서 쓸 수 있도록 해제
> 
> N = 10
> R = 3
> a = [i for i in range(1,N+1)]
> used = [0] * N
> p = [0] * R
> f(0,N, R)
> ```
> 
> ```python
> # 자리를 고정하는 순열
> def f(i,k, r):
>     if i == r:
>         print(p)
>     else:
>         for j  in range(k):
>             if not used[j]:         # a[j]가 아직 사용되지 않았으면
>                 used[j] = 1         # a[j] 사용됨으로 표시
>                 p[i] = a[j]         # p[i]는 a[j]로 결정
>                 f(i+1,k,r)            # p[i+1] 값을 결정하러 이동
>                 used[j] = 0         # a[j]를 다른 자리에서 쓸 수 있도록 해제
> 
> N = 10
> R = 3
> a = [i for i in range(1,N+1)]
> used = [0] * N
> p = [0] * R
> used[0] = 1    # 첫번째 자리를 고정
> f(1,N, R)
> ```

---

## 4. 부분 집합

- **개념**

> - 집합에 포함된 원소들을 선택하는 것.
> - N개의 원소를 포함한 집합
>   - 자기 자신과 공집합 포함한 모든 부분 집합의  개수는 2^n개
>   - 원소의 수가 증가하면 부분 집합의 개수는 지수 적으로 증가한다.

- **생성 방법**

> - **바이너리 카운팅**
>   
>   - 바이너리 카운팅을 통한  사전적 순서
>     
>     - 부분 집합을 생성하기 위한 가장 자연스러운 방법
>     - 바이너리 카운팅(Binary Counting)은 사전적 순서로 생성하기 위한 가장 간단한 방법
>   
>   - 원소 수에 해당하는 N개의 비트 열을 이용
>   
>   - n번째 비트 값이 1이면 n번째 원소가 포함되었음을 의미
>   
>   - ![화면 캡처 2022-09-21 133905](C:.\화면 캡처 2022-09-21 133905.png)
>   
>   - ```python
>     # 바이너리 카운팅
>     arr = [3,6,7,1,5,4]
>     n = len(arr)
>         
>     for i in range(0,(1<<n)):    # 1<<n : 부분 집합의 개수
>         for j in range(0,n):    # 원소의 수만큼 비트를 비교함
>             if i&(1<<j):        # i의 j번째 비트가 1이면 j번째 원소 출력
>                 print('%d'%arr[j],end='')
>         print() 
>     ```
>   
>   - ```pyth
>     # 재귀로 구하기
>     def f(i,k):
>         if i==k:
>             # print(bit)
>             for j in range(k):
>                 if bit[j]:
>                     print(arr[j],end=' ')
>             print()
>         else:
>             bit[i] = 0
>             f(i+1,k)
>             bit[i] = 1
>             f(i+1,k)
>         
>     arr = [3,6,7]
>     n = len(arr)
>         
>     bit = [0]*n
>     f(0,n)
>     ```

---

## 5. 조합

- **개념**

> - 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것
> - nCr = n! / (n-r)!r!, 단 (n>=r)
> - nCr = (n-1)C(r-1) +(n-1)Cr -> 재귀적 표현
> - nC0 = 1

- **생성**

> ```python
> # 반복문을 이용
> N = 10
> for i in range(N-2):
>     for j in range(i+1,N-1):
>         for k in range(j+1,N):
>             print(i,j,k)
> ```
> 
> ```python
> # 재귀를 이용한 방법
> def comb(n,r):
>     if r == 0:
>         print arr
>     elif n < r:
>         return
>     else:
>         tr[r-1] = an[n-1]
>         comb(n-1,r-1)
>         comb(n-1,r)
> an = [1,2,4,5]    # n개의 원소를 가지고 있는 배열
> n = len(an)
> tr = [0]*R        # r개의 크기의 배열, 조합이 임시 저장될 배열
> comb(0,R)
> ```
> 
> ```python
> # n개에서 r개를 고르는 조합, s부터 시작
> def nCr(n,r,s):
>     if r==0:
>         print(*comb)
>     else:
>         for i in range(s,n-r+1):
>             comb[r-1] = A[i]
>             nCr(n,r-1,i+1)
> A = [1,2,3,4,5]
> n = len(A)
> r = 3
> comb = [0]*r
> ```

---

## 6. 탐욕 알고리즘

- **개념**

> - 최적 해를 구하는 데 사용되는 근시안적인 방법
> - 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현
> - 여러 경우 중 하나를 선택 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
> - 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, **그것이 최적이라는 보장이 없다.**
> - 한번 선택된 것은 번복하지 않는다. 그래서 제한적인 문제들에 적용된다.

- **동작 과정**

> - **해 선택** : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합에 추가
> - **실행 가능성 검사** : 새로운 부분 해 집합이 실행 가능한 지를 확인 -> 문제의 제약 조건을 위반하지 않는 지를 검사
> - **해 검사** : 새로운 부분 해 집합이 문제의 해가 되는지를 확인. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작

- **필수 요소**

> - **탐욕적 선택 속성**
>   - 탐욕적 선택은 최적 해로 갈 수 있음을 보여야 한다.
>   - 즉, 탐욕적 선택은 항상 안전
> - **최적 부분 구조**
>   - 최적화 문제를 정형화
>   - 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.
> - **원 문제의 최적 해 = 탐욕적 선택 + 하위 문제의 최적 해 임을 증명**
> - ![화면 캡처 2022-09-21 153811](C:.\화면 캡처 2022-09-21 153811.png)
> - ![화면 캡처 2022-09-21 153837](C:.\화면 캡처 2022-09-21 153837.png)

---

## 7. 활동 선택 문제

- **탐욕 기법의 적용**

> - 공 집합이 아닌 하위 문제 Sij가 있고 Sij에 속한 활동 Am은 종료 시간이 가장 빠른 활동.
> - 1. 하위 문제 Sij 에서 종료 시간이 가장 빠른 활동 Am을 선택
>   2. Sim은 공  집합이므로, Am을 선택하면 공 집합이 아닌 하위 문제 Smj가 남는다.
>   3. (1) (2) 과정을 반복한다.
> - ![화면 캡처 2022-09-21 151213](C:./화면 캡처 2022-09-21 151213.png)

---

## 8. Baby-jin

```python
# 완전 검색이 아닌 방법으로 풀기
'''
5
123123
124467
333444
444456
123444
'''
def f(i,k):
    if i==k:
        # print(card)
        run = 0
        tri = 0
        if card[0]==card[1] and  card[1]==card[2]:
            tri += 1
        if card[0]+1==card[1] and card[1]+1==card[2]:
            run += 1
        if card[3]==card[4] and  card[4]==card[5]:
            tri += 1
        if card[3]+1==card[4] and card[4]+1==card[5]:
            run += 1
        if tri+run==2:
            return 1
        else:
            return 0
    else:
        for j in range(i,k):
            card[i],card[j]=card[j],card[i]
            if f(i+1,k):
                return 1
            card[i],card[j]=card[j],card[i]
        return 0

T = int(input())
for tc in range(1,T+1):
    card = list(map(int,input()))
    ans = f(0,6)
    if ans:
        print(f'#{tc} Baby Gin')
    else:
        print(f'#{tc} Lose')
```

```python
# 두번째 방법
T = int(input())
for tc in range(1,T+1):
    card = int(input)
    c = [0]*12
    i = 0
    while i<6:
        c[card%10] += 1
        card //= 10
        i += 1
    tri = 0
    run = 0
    i = 1
    while i < 10:
        if c[i] >= 3:
            c[i] -= 3
            tri += 1
            continue
        if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
            c[i] -= 1
            c[i+1] -= 1
            c[i+2] -= 1
            run += 1
            continue
        i += 1
    if run + tri == 2:
        print(f'#{tc} Baby Gin')
    else:
        print(f'#{tc} Lose')
```
