# JavaScript

---

## 1. JavaScript 시작하기 

- ### 실행하기

  1. **Web Browser로 실행하기**

     - **방법 1**
       - ![화면 캡처 2022-10-19 093946](C:.\화면 캡처 2022-10-19 093946.png)

     

     - **방법 2**
       - ![화면 캡처 2022-10-19 094229](C:.\화면 캡처 2022-10-19 094229.png)

     

     - **결과 확인**
       - ![화면 캡처 2022-10-19 094038](C:.\화면 캡처 2022-10-19 094038.png)

     

     - **방법 3**
       - ![화면 캡처 2022-10-19 094714](C:.\화면 캡처 2022-10-19 094714.png)

  2. **Node.JavaScript로 실행하기**

     - ![화면 캡처 2022-10-19 094924](C:.\화면 캡처 2022-10-19 094924.png)

     

---

## 2. JavaScript 기본 문법 - 1

- ### 코드 작성법

  - **세미콜론 (semicolon)**
    - 자바스크립트는 세미콜론을 선택적으로 사용 가능하다.
    - 세미콜론이 없으면 ASI에 의해 **자동으로 세미콜론이 삽입**된다.
      - ASI (Automatic Semicolon Insertion, 자동 세미콜론 삽입 규칙)
    - ![화면 캡처 2022-10-19 095540](C:.\화면 캡처 2022-10-19 095540.png)

  

  - **들여쓰기와 코드 블럭**
    - javaScript는 2칸 들여쓰기를 사용한다.
    - 블럭(block)은 if, for, 함수에서 중괄호 { } 내부를 말한다.
      - python은 들여쓰기를 이용해 코드 블럭을 구분
      - JavaScript는 중괄호 {}를 사용해 코드 블럭을 구분
    - ![화면 캡처 2022-10-19 095733](C:.\화면 캡처 2022-10-19 095733.png)

  

  - **코드 스타일 가이드**
    - JavaScript는 여러 코드 스타일 가이드가 회사마다 존재한다.
    - ex)
      - Airbnb JavaScript Style Guide
      - Google JavaScript Style Guide
      - standardJavaScript
  - **주석**
    - 한 줄 주석 (//) 과 여러 줄 (/**/) 주석
    -  ![화면 캡처 2022-10-19 100228](C:.\화면 캡처 2022-10-19 100228.png)

  

- ### 변수와 식별자

  - **식별자 정의와 특징**

    - 식별자(identifier)는 변수를 구분할 수 있는 변수명을 말한다.
    - 식별자는 반드시 문자, 달러($) 또는 밑줄(_)로 시작한다.
    - **대소문자를 구분하며, 클래스명 외에는 모두 소문자로 시작**
    - 예약어 사용 불가능하다.

    

    - **카멜 케이스 (camelCase, loser-camel-case)**
      - 변수, 객체, 함수에 사용한다.
      - ![화면 캡처 2022-10-19 100732](C:.\화면 캡처 2022-10-19 100732.png)

    

    - **파스칼 케이스 (PascalCase, upper-camel-case)**
      - 클래스, 생성자에 사용한다.
      - ![화면 캡처 2022-10-19 100755](C:.\화면 캡처 2022-10-19 100755.png)

    

    - **대문자 스네이크 케이스 (SNAKE_CASE)**
      - 상수(constants)에 사용한다.
      - 상수 : 개발자의 의도와 상관없이 변경될 가능성이 없는 값을 의미한다.
      - ![화면 캡처 2022-10-19 100817](C:.\화면 캡처 2022-10-19 100817.png)

  

  - **변수 선언 키워드**

    - **선언**

      - 변수를 생성하는 행위 또는 시점

    - **할당**

      - 선언된 변수에 값을 저장하는 해위 또는 시점

    - **초기화**

      - 선언된 변수에 처음으로 값을 저장하는 행위 또는 시점

      

    - ![화면 캡처 2022-10-19 101227](C:.\화면 캡처 2022-10-19 101227.png)

    

    - **블록 스코프 (block scope)**
      - if, for, 함수 등의 중괄호 내부를 가리킨다.
      - 블록 스코프를 가지는 변수는 블록 바깥에서 접근 불가능하다.
      - ![화면 캡처 2022-10-19 101342](C:.\화면 캡처 2022-10-19 101342.png)

    

    - **함수 스코프 (function scope)**
      - 함수의 중괄호 내부를 가리킨다.
      - 함수 스코프를 가지는 변수는 함수 바깥에서 접근 불가능하다.
      - ![화면 캡처 2022-10-19 102032](C:.\화면 캡처 2022-10-19 102032.png)

    

    - **호이스팅 (hoisting)**

      - **변수를 선언 이전에 참조할 수 있는 현상**
      - **var로 선언된 변수는 선언 이전에 참조**할 수 있으며, **이러한 현상을 호이스팅**이라고 한다.
      - **변수 선언 이전의 위치에서 접근 시 undefined를 반환**한다.
      - JavaScript에서 변수들은 실제 실행시에 코드의 최상단으로 끌어 올려지게 되며 이러한 이유때문에 var로 선언된 변수는 선언 시에 undefined로 값이 초기화되는 과정이 동시에 일어난다.
      - 반면 let, const는 호이스팅이 일어나면 에러를 발생시킨다.
      - ![화면 캡처 2022-10-19 102321](C:.\화면 캡처 2022-10-19 102321.png)

      

    - **let**

      - 블록 스코프 지역 변수를 선언 (추가로 동시에 값을 초기화)
      - **재할당 가능 & 재선언 불가능**
      - **블록 스코프를 갖는 지역 변수를 선언**, 선언과 동시에 **원하는 값으로 초기화** 할 수 있다.
      - ![화면 캡처 2022-10-19 101523](C:.\화면 캡처 2022-10-19 101523.png)

    

    - **const**

      - 블록 스코프 읽기 전용 상수를 선언 (추가로 동시에 값을 초기화)
      - **재할당 불가능 & 재선언 불가능**
      - **선언 시 반드시 초기값을 설정**해야 하며, **이후 값 변경이 불가능**하다.
      - let과 동일하게 블록 스코프를 가진다.
      - ![화면 캡처 2022-10-19 101620](C:.\화면 캡처 2022-10-19 101620.png)

      

    - **var**

      - 변수를 선언 (추가로 동시에 값을 초기화)
      - **재할당 가능 & 재선언 가능**
      - ES6 이전에 변수를 선언할 때 사용되던 키워드
      - **"호이스팅"** 되는 특성으로 인해 예기치 못한 문제가 발생할 수 있다.
        - ES6 이후부터는 **var 대신 const와 let을 사용하는 것을 권장**한다.
      - 함수 스코프 (function scope)를 가진다.
      - **변수 선언 시 var, const, let 키워드 중 하나를 사용하지 않으면 자동으로 var로 선언된다.**

    

    - **정리**
      - ![화면 캡처 2022-10-19 102919](C:.\화면 캡처 2022-10-19 102919.png)
      - **Airbnb 스타일 가이드에서는 기본적으로 const 사용을 권장**
        - 재할당해야 하는 경우만 let



- ### 데이터 타입

  - JavaScript의 모든 값은 특정한 데이터 타입을 가진다.
  - **원시 타입 (Primitive type)**과 **참조 타입 (Reference type)**으로 분류된다.
    - ![화면 캡처 2022-10-19 103203](C:.\화면 캡처 2022-10-19 103203.png)

  

  - **Number**

    - 정수 또는 실수형 숫자를 표현하는 자료형

    - ![화면 캡처 2022-10-19 103254](C:.\화면 캡처 2022-10-19 103254.png)

    - **NaN**

      - **Not-A-Number (숫자가 아님)를 나타낸다.**
      - **Number.isNaN()** 의 경우 **주어진 값의 유형이 Number**이고 **값이 NaN이면 true 아니면 false를 반환**한다.

      

      - **NaN을 반환하는 경우**
        1. 숫자로 읽을 수 없음 (parseInt("가나다"), Number(undefined))
        2. 결과가 허수인 수학 계산식 (Math.sqrt(-1))
        3. 피연산자가 NaN (7 ** NaN)
        4. 정의할 수 없는 계산식 (0 * Infinity)
        5. 문자열을 포함하면서 덧셈이 아닌 계산식 ("가" / 3)

  

  - **String**

    - 문자열을 표현하는 자료형

    - 작은 따옴표 혹은 큰 따옴표 모두 사용 가능하다.

      - ![화면 캡처 2022-10-19 103715](C:.\화면 캡처 2022-10-19 103715.png)

    - 곱셈 나눗셈, 뺄셈은 안되지만 덧셈을 통해 문자열 붙일 수 있다.

      - ![화면 캡처 2022-10-19 103739](C:.\화면 캡처 2022-10-19 103739.png)

    - Quote를 사용하면 선언 시 줄 바꿈이 안된다.

    - 대신 escape sequence를 사용할 수 있기 때문에 \n를 사용해야 한다.

      - ![화면 캡처 2022-10-19 103834](C:.\화면 캡처 2022-10-19 103834.png)

    - Template Literal을 사용하면 줄바꿈이 되며, 문자열 사이에 변수도 삽입도 가능하다.

      - **Template literals (템플릿 리터럴)**
        - 내장된 표현식을 허용하는 문자열 작성 방식
        - ES6+ 부터 지원
        - **Backtick(``)을 이용하며, 여러 줄에 걸쳐 문자열을 정의할 수도 있고 JavaScript의 변수를 문자열 안에 바로 연결할 수 있는 이점이 생긴다.**
        - **표현식을 넣을 수 있고, $와 중괄호 ($ {expression})로 표기한다.**

    - (단, escape sequence를 사용할 수 없다.) == Python의 "f-string"

      - ![화면 캡처 2022-10-19 103943](C:.\화면 캡처 2022-10-19 103943.png)

      

  - **Empty Value**

    - 값이 존재하지 않음을 표현하는 값, **null과 undefined가 존재**한다.
    - 동일한 역할을 하는 이 두 개의 키워드가 존재하는 이유는 설계 실수이다.

    

    - **null**
      - null 값을 나타내는 특별한 키워드
      - 변수의 **값이 없음을 의도적으로 표현**할 때 사용하는 데이터 타입
      - ![화면 캡처 2022-10-19 104410](C:.\화면 캡처 2022-10-19 104410.png)

    

    - **undefined**
      - 값이 정의되어 있지 않음을 표현하는 값
      - 변수 선언 이후 직접 값을 할당하지 않으면 자동으로 할당된다.
      - ![화면 캡처 2022-10-19 104507](C:.\화면 캡처 2022-10-19 104507.png)

    

    - **null과 undefined의 차이점**
      - null과 undefined의 가장 대표적인 차이점은 typeof 연산자를 통해 타입을 확인 했을 때 나타난다.
      - null이 **원시 타입임에도 object로 출력되는 이유**는 설계 당시의 버그이다.
      - ![화면 캡처 2022-10-19 104643](C:.\화면 캡처 2022-10-19 104643.png)

  

  - **Boolean**
    - **true와 false**
    - 참과 거짓을 표현하는 값
    - **조건문 또는 반복문에서 유용하게 사용한다.**
      - 조건문 또는 반복문에서 boolean이 아닌 데이터 타입은 자동 형변환 규칙에 따라 true 또는 false로 변환된다.
      - ![화면 캡처 2022-10-19 104846](C:.\화면 캡처 2022-10-19 104846.png)



- ### 연산자

  - **할당 연산자**
    - 오른쪽에 있는 피연산자의 평가 결과를 왼쪽 피연산자에 할당하는 연산자
    - **다양한 연산에 대한 단축 연산자 지원**
    - Increment 및 Decrement 연산자
      - Increment(++) : 피연산자의 값을 1 증가시키는 연산자
      - Decrement(--) : 피연산자의 값을 1 감소시키는 연산자
      - **+= 또는 -=와 같이 더 분명한 표현으로 적을 것을 권장한다.**
    - ![화면 캡처 2022-10-19 105122](C:.\화면 캡처 2022-10-19 105122.png)

  

  - **비교 연산자**
    - **피연산자들 (숫자, 문자, Boolean 등)을 비교하고 결과 값을 boolean으로 반환하는 연산자**
    - 문자열은 **유니코드 값을 사용하며 표준 사전 순서를 기반으로 비교**한다.
      - ex) 알파벳끼리 비교할 경우
        - 알파벳 순서상 후순위가 더 크다.
        - 소문자가 대문자보다 더 크다.
    - ![화면 캡처 2022-10-19 105309](C:.\화면 캡처 2022-10-19 105309.png)

  

  - **동등 연산자 (==)**
    - 두 피연산자가 같은 값으로 평가되는지 비교 후 boolean 값을 반환한다.
    - 비교할 때 **암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교**한다.
    - 두 피연산자가 모두 객체일 경우 메모리의 같은 객체를 바라보는지 판별한다.
    - **예상치 못한 결과가 발생할 수 있으므로 특별한 경우를 제외하고 사용하지 않는다.**
    - ![화면 캡처 2022-10-19 105453](C:.\화면 캡처 2022-10-19 105453.png)

  

  - **일치 연산지(===)**
    - 두 피연산자의 값과 타입이 모두 같은 경우 true를 반환한다.
    - 같은 객체를 가리키거나, 같은 타입이면서 같은 값인지를 비교한다.
    - **엄격한 비교가 이뤄지며 암묵적 타입 변환이 발생하지 않는다.**
      - **엄격한 비교**
        - 두 비교 대상의 타입과 값 모두 같은 지 비교하는 방식
    - ![화면 캡처 2022-10-19 105641](C:.\화면 캡처 2022-10-19 105641.png)

  

  - **논리 연산자**
    - **세 가지 논리 연산자로 구성**
      - and : '&&'
      - or : '||'
      - not : '!'
    - 단축 평가 지원
      - ex)
        - false && true => false
        - true || false => true
    - ![화면 캡처 2022-10-19 105808](C:.\화면 캡처 2022-10-19 105808.png)

  

  - **삼항 연산자**
    - 3 개의 피연산자를 사용하여 조건에 따라 값을 반환하는 연산자
    - 가장 앞의 조건식이 참이면 : 앞의 값이 반환되며, 그 반대일 경우 : 뒤의 값이 반환되는 연산자
    - 삼항 연산자의 결과 값이기 때문에 변수에 할당 가능하다.
    - ![화면 캡처 2022-10-19 105927](C:.\화면 캡처 2022-10-19 105927.png)



- ### 조건문

  - **조건문의 종류와 특징**

    - **if statement**

      - 조건 표현식의 결과 값을 **boolean 타입으로 변환 후 참/거짓을 판단**한다.
      - **if, else if, else**
        - 조건은 소괄호 안에 작성한다.
        - 실행할 코드는 중괄호{} 안에 작성
        - 블록 스코프 생성
        - ![화면 캡처 2022-10-19 110356](C:.\화면 캡처 2022-10-19 110356.png)

      

    - **switch statement**

      - 조건 표현식의 결과값이 **어느 값(case)에 해당하는지 판별**
      - 주로 특정 변수의 값에 따라 조건을 분기할 때 활용
        - 조건이 많아질 경우 if문보다 가독성이 나을 수 있다.
      - **표현식의 결과값을 이용한 조건문**
      - **표현식의 결과값과 case문의 오른쪽 값을 비교**
      - break 및 default문은 [선택적]으로 사용 가능하다.
      - break문이 없는 경우 break문을 만나거나 default문을 실행할 때까지 다음 조건문 실행
      - 블록 스코프 생성
      - ![화면 캡처 2022-10-19 110552](C:.\화면 캡처 2022-10-19 110552.png)
      - ex)
        - ![화면 캡처 2022-10-19 110706](C:.\화면 캡처 2022-10-19 110706.png)
        - ![화면 캡처 2022-10-19 110731](C:.\화면 캡처 2022-10-19 110731.png)

    - **if / switch 차이**

      - 조건이 많은 경우 switch문을 통해 가독성 향상을 기대할 수 있다.
      - 일반적으로 중첩 else if문은 유지 보수하기 힘들다는 문제가 있다.
      - ![화면 캡처 2022-10-19 111022](C:.\화면 캡처 2022-10-19 111022.png)



- ### 반복문

  - **while**
    - 조건문이 참이기만 하면 문장을 계속해서 수행
    - ![화면 캡처 2022-10-19 111314](C:.\화면 캡처 2022-10-19 111314.png)

  

  - **for**
    - 특정한 조건이 거짓으로 판별될 때까지 반복
    - ![화면 캡처 2022-10-19 111352](C:.\화면 캡처 2022-10-19 111352.png)
    - ex)
      - ![화면 캡처 2022-10-19 111441](C:.\화면 캡처 2022-10-19 111441.png)

  

  - **for in**
    - **객체(object)의 속성을 순회**할 때 사용한다.
    - 배열도 순회 가능하지만 인덱스 순으로 순회한다는 보장이 없으므로 권장하지 않는다.
    - ![화면 캡처 2022-10-19 111557](C:.\화면 캡처 2022-10-19 111557.png)
    - ex)
      - ![화면 캡처 2022-10-19 111626](C:.\화면 캡처 2022-10-19 111626.png)

  

  - **for of**
    - **반복 가능한 객체를 순회**할 때 사용한다.
    - 반복 가능한(iterable) 객체의 종류 : Array, Set, String ..
    - ![화면 캡처 2022-10-19 111736](C:.\화면 캡처 2022-10-19 111736.png)
    - ex)
      - ![화면 캡처 2022-10-19 111802](C:.\화면 캡처 2022-10-19 111802.png)

  

  - **for in 과 for of 차이**
    - for in은 속성 이름을 통해 반복
    - for of는 속성 값을 통해 반복
    - ![화면 캡처 2022-10-19 111855](C:.\화면 캡처 2022-10-19 111855.png)
    - ![화면 캡처 2022-10-19 112140](C:.\화면 캡처 2022-10-19 112140.png)
    - **일반적인 for문의 경우에는 최초 정의한 i를 재할당 하면서 사용하기 때문에 const를 사용하면 에러가 발생한다.**
    - **for in, for of의 경우에는 재할당이 아니라, 매 반복 시 해당 변수를 새로 정의하여 사용하므로 에러가 발생하지 않는다.**

  

  - **정리**
    - ![화면 캡처 2022-10-19 112403](C:.\화면 캡처 2022-10-19 112403.png)

---

## 3. JavaScript 기본 문법 -2

- ### 함수의 정의

  - **함수 선언식 (Function declaration)**
    - 일반적인 프로그래밍 언어의 함수 정의 방식
      - ![화면 캡처 2022-10-19 133518](C:.\화면 캡처 2022-10-19 133518.png)
    - ex)
      - ![화면 캡처 2022-10-19 133546](C:.\화면 캡처 2022-10-19 133546.png)
        - **실제 반환 값을 확인할려면 console.log(add(2,7))을 해야한다.**

  

  - **함수 표현식 (Function expression)**
    - 표현식 내에서 함수를 정의하는 방식
    - 함수 표현식은 함수의 이름을 생략한 익명 함수로 정의 가능하다.
      - ![화면 캡처 2022-10-19 133832](C:.\화면 캡처 2022-10-19 133832.png)
    - 표현식에서 함수 이름을 명시하는 것도 가능하다.
    - 이 경우 함수 이름은 호출에 사용되지 못하고 디버깅 용도로 사용된다.
      - ![화면 캡처 2022-10-19 133957](C:.\화면 캡처 2022-10-19 133957.png)
    - ex)
      - ![화면 캡처 2022-10-19 133857](C:.\화면 캡처 2022-10-19 133857.png)

  

  - **기본 인자**
    - 인자 잣성 시 '=' 문자 뒤 기본 인자 선언 가능하다.
      - ![화면 캡처 2022-10-19 134205](C:.\화면 캡처 2022-10-19 134205.png)

  

  - **매개변수와 인자의 개수 불일치 허용**
    - 매개변수보다 인자의 개수가 많을 경우
      - ![화면 캡처 2022-10-19 134304](C:.\화면 캡처 2022-10-19 134304.png)
    - 매개변수보다 인자의 개수가 적을 경우
      - ![화면 캡처 2022-10-19 134335](C:.\화면 캡처 2022-10-19 134335.png)

  

  - **Spread syntax(...)**
    - '전개 구문'
    - 전개 구문을 사용하면 배열이나 문자열과 같이 반복 가능한 객체를 배열의 경우는 요소, 함수의 경우는 인자로 확장할 수 있다.
      1. **배열과의 사용**
         - ![화면 캡처 2022-10-19 134515](C:.\화면 캡처 2022-10-19 134515.png)
      2. **함수와의 사용 (Rest parameters)**
         - The rest parameter syntax를 사용하여 정해지지 않은 수의 매개변수를 배열로 받을 수 있다.
         - ![화면 캡처 2022-10-19 134604](C:.\화면 캡처 2022-10-19 134604.png)



- ### 선언식과 표현식

  - **함수의 타입**
    - 선언식 함수와 표현식 함수 모두 타입은 function으로 동일하다.
    - ![화면 캡처 2022-10-19 134704](C:.\화면 캡처 2022-10-19 134704.png)

  

  - **호이스팅 - 선언식**
    - **함수 선언식으로 정의한 함수는 var 로 정의한 변수처럼 호이스팅이 발생**한다.
    - 즉 함수 호출 이후에 선언해도 동작한다.
    - ![화면 캡처 2022-10-19 134808](C:.\화면 캡처 2022-10-19 134808.png)

  

  - **호이스팅 - 표현식**
    - 함수 표현식으로 선언한 함수는 함수 정의 전에 호출 시 에러가 발생한다.
    - 함수 표현식으로 정의된 함수는 변수로 평가되어 변수의 scope 규칙을 따른다.
    - ![화면 캡처 2022-10-19 134949](C:.\화면 캡처 2022-10-19 134949.png)

  

  - **정리**
    - ![화면 캡처 2022-10-19 135032](C:.\화면 캡처 2022-10-19 135032.png)



- ### Arrow Function

  - **화살표 함수 (Arrow Function)**

    - 함수를 비교적 간결하게 정의할 수 있는 문법
    - function 키워드와 중괄호를 이용한 구문을 짧게 사용하기 위해 탄생했다.
      1. **function 키워드 생략 가능**
      2. **함수의 매개변수가 하나뿐이라면 '()'도 생략 가능**
      3. **함수의 내용이 한 줄이라면 '{}' 와 'return'도 생략 가능**
    - **화살표 함수는 항상 익명 함수**
      - == 함수 표현식에서만 사용 가능
    - ![화면 캡처 2022-10-19 135304](C:\Users\GNSS\Desktop\git\필기\javascript\화면 캡처 2022-10-19 135304.png)

    

    - **응용**
      - ![화면 캡처 2022-10-19 135614](C:.\화면 캡처 2022-10-19 135614.png)

  

  - **즉시 실행 함수**
    - 선언과 동시에 실행되는 함수
    - **함수의 선언 끝에 '()'를 추가하여 선언되자 마자 실행**하는 형태
    - '()' 에 값을 넣어 인자로 넘겨줄 수 있다.
    - 즉시 실행 함수는 선언과 동시에 실행되기 때문에 같은 함수를 다시 호출할 수 없다.
    - **초기화 부분에 많이 사용된다.**
    - **일회성 함수이므로 익명함수로 사용하는 것이 일반적이다.**
    - ![화면 캡처 2022-10-19 140011](C:.\화면 캡처 2022-10-19 140011.png)



- ### Array와 Object

  - **배열 (Array)**

    - 키와 속성들을 담고 있는 참조 타입의 **객체(object)**
    - 순서를 보장하는 특징이 있다.
    - 주로 대활호를 이용하여 생성하고, **0을 포함한 양의 정수 인덱스로 특정 값에 접근 가능**하다.
    - 배열의 길이는 array.length 형태로 접근 가능하다.
      - 배열의 마지막 원소는 array.length -1 로 접근
    - ![화면 캡처 2022-10-19 141017](C:.\화면 캡처 2022-10-19 141017.png)

    

  - **배열 메서드 기초**

    - ![화면 캡처 2022-10-19 141123](C:.\화면 캡처 2022-10-19 141123.png)

    

    - [x] **array.reverse()**
      - 원본 배열 요소들의 순서를 반대로 정렬
        - ![화면 캡처 2022-10-19 141235](C:.\화면 캡처 2022-10-19 141235.png)

    

    - [x] **array.push() / array.pop()**
      - 배열의 가장 뒤에 요소 추가
      - 배열의 마지막 요소 제거
      - ![화면 캡처 2022-10-19 141340](C:.\화면 캡처 2022-10-19 141340.png)

    

    - [x] **array.includes(value)**
      - 배열에 특정 값이 존재하는지 판별 후 참 또는 거짓 반환
      - ![화면 캡처 2022-10-19 141848](C:.\화면 캡처 2022-10-19 141848.png)

    

    - [x] **array.indexOf(value)**
      - 배열에 특정 값이 존재하는지 확인 후 가장 첫 번째로 찾은 요소의 인덱스 반환
      - 만약 해당 값이 없을 경우 -1 반환
      - ![화면 캡처 2022-10-19 142037](C:.\화면 캡처 2022-10-19 142037.png)

    

    - [x] **array.join([separator])**
      - 배열의 모든 요소를 연결하여 반환
      - separator(구분자)는 선택적으로 지정 가능하며, 생략 시 쉼표를 기본 값으로 사용한다.
      - ![화면 캡처 2022-10-19 142337](C:.\화면 캡처 2022-10-19 142337.png)

  

  - **배열 메서드 심화**

    - 배열을 순회하며 특정 로직을 수행하는 메서드
    - 메서드 호출 시 인자로 callback 함수를 받는 것이 특징이다.
      - **callback 함수** : 어떤 함수의 내부에서 실행될 목적으로 인자로 넘겨받는 함수
    - ![화면 캡처 2022-10-19 142500](C:.\화면 캡처 2022-10-19 142500.png)

    

    - [x] **Array Helper Methods - forEach**
      - ![화면 캡처 2022-10-19 142559](C:.\화면 캡처 2022-10-19 142559.png)
      - array.forEach(callback(element[, index[,array]]))
      - **인자로 주어지는 함수 (콜백 함수)를 배열의 각 요소에 대해 한 번씩 실행**
        - **콜백 함수는 3가지 매개변수로 구성**
          1. **element : 배열의 요소**
          2. **index : 배열 요소의 인덱스**
          3. **array : 배열 자체**
      - 반환 값(return) 없음
      - ![화면 캡처 2022-10-19 142753](C:.\화면 캡처 2022-10-19 142753.png)

    

    - [x] **Array Helper Methods - map**
      - ![화면 캡처 2022-10-19 142831](C:.\화면 캡처 2022-10-19 142831.png)
      - array.map(callback(element[,index[,array]]))
      - **배열의 각 요소에 대해 콜백 함수를 한 번씩 실행**
      - **콜백 함수의 반환 값을 요소로 하는 새로운 배열 반환**
      - 기존 배열 전체를 다른 형태로 바꿀 때 유용
        - **forEach + return 이라고 생각하면 편하다.**
      - ![화면 캡처 2022-10-19 142949](C:.\화면 캡처 2022-10-19 142949.png)

    

    - [x] **Array Helper Methods - filter**
      - ![화면 캡처 2022-10-19 143033](C:\Users\GNSS\Desktop\git\필기\javascript\화면 캡처 2022-10-19 143033.png)
      - array.filter(callback(element[,index[,array]]))
      - 배열의 각 요소에 대해 콜백 함수를 한 번씩 실행
      - **콜백 함수의 반환 값이 참인 요소들만 모아서 새로운 배열 반환**
      - **기존 배열의 요소들을 필터링할 때 유용**
      - ![화면 캡처 2022-10-19 143145](C:.\화면 캡처 2022-10-19 143145.png)

    

    - [x] **Array Helper Methods - reduce**
      - ![화면 캡처 2022-10-19 143223](C:.\화면 캡처 2022-10-19 143223.png)
      - array.reduce(callback(acc, element[index[,array]])[,initiaValue]
      - 인자로 주어지는 함수 (콜백 함수)를 배열의 각 요소에 대해 한 번씩 실행해서. 하나의 결과 값을 반환
      - **즉, 배열을 하나의 값으로 계산하는 동작이 필요할 때 사용 (총합, 평균 등)**
      - **map, filter 등 여러 배열 메서드 동작을 대부분 대체할 수 있다.**
      - **reduce 메서드의 주요 메개변수**
        - **acc**
          - 이전 callback 함수의 반환 값이 누적되는 변수
        - **initialValue(optional)**
          - 최초 callback 함수 호출 시 acc에 할당되는 값, default 값은 배열의 첫 번째 값
      - reduce의 첫 번째 매개변수인 콜백함수의 첫 번째 매개변수(`acc`)는 누적된 값(전 단계까지의 결과)
      - reduce의 두 번째 매개변수인 'initialValue'는 누적될 값의 초기값, 지정하지 않을 시 첫 번째 요소의 값이 된다.
        - **빈 배열의 경우 initialValue를 제공하지 않으면 에러가 발생한다.**
      - ![화면 캡처 2022-10-19 144313](C:\Users\GNSS\Desktop\git\필기\javascript\화면 캡처 2022-10-19 144313.png)
      - ![화면 캡처 2022-10-19 144950](C:.\화면 캡처 2022-10-19 144950.png)

    

    - [x] **Array Helper Methods - find**
      - ![화면 캡처 2022-10-19 145314](C:.\화면 캡처 2022-10-19 145314.png)
      - array.find(callback(element[,index[,array]]))
      - 배열의 각 요소에 대해 콜백 함수를 한 번씩 실행
      - **콜백 함수의 반환 값이 참이면, 조건을 만족하는 첫번째 요소를 반환**
      - 찾는 값이 배열에 없으면 undefined 반환
      - ![화면 캡처 2022-10-19 145439](C:.\화면 캡처 2022-10-19 145439.png)

    

    - [x] **Array Helper Methods - some**
      - array.some(callback(element[,index[,array]]))
      - **배열의 요소 중 하나라도 주어진 판별 함수를 통과하면 참을 반환**
      - **모든 요소가 통과하지 못하면 거짓 반환**
      - 빈 배열은 항상 false 반환
      - ![화면 캡처 2022-10-19 145608](C:.\화면 캡처 2022-10-19 145608.png)

    

    - [x] **Array Helper Methods - every**
      - ![화면 캡처 2022-10-19 145953](C:.\화면 캡처 2022-10-19 145953.png)
      - array.every(callback(element[,index[,array]]))
      - **배열의 모든 요소가 주어진 판별 함수를 통과하면 참을 반환**
      - 하나의 요소라도 통과하지 못하면 거짓 반환
      - 빈 배열은 항상 true 반환
      - ![화면 캡처 2022-10-19 150128](C:.\화면 캡처 2022-10-19 150128.png)

    

    - [x] ![화면 캡처 2022-10-19 150347](C:.\화면 캡처 2022-10-19 150347.png)



- ### 객체 (object)

  - 객체는 속성의 집합이며, 중괄호 내부에 key와 value의 쌍으로 표현
  - **key는 문자열 타입**만 가능하다.
    - key 이름에 **띄어쓰기 등의 구분자가 있으면 따옴표**로 묶어서 표현
  - **value는 모든 타입(함수포함)** 가능
  - 객체 요소 **접근은 점(.) 또는 대괄호([])**로 가능
    - key 이름에 **띄어쓰기 같은 구분자가 있으면 대괄호 접근**만 가능
  - ![화면 캡처 2022-10-19 152523](C:.\화면 캡처 2022-10-19 152523.png)

  

  - **객체 관련 문법**
    1. **속성명 축약**
       - 객체를 정의할 때 key와 할당하는 변수의 이름이 같으면 축약 가능
       - ![화면 캡처 2022-10-19 152702](C:.\화면 캡처 2022-10-19 152702.png)
    2. **메서드명 축약**
       - 메서드 선언 시 function 키워드 생략 가능
       - ![화면 캡처 2022-10-19 152735](C:.\화면 캡처 2022-10-19 152735.png)
    3. **계산된 속성명 사용하기**
       - 객체를 정의할 때 key의 이름을 표현식을 이용하여 동적으로 생성 가능
       - ![화면 캡처 2022-10-19 152816](C:.\화면 캡처 2022-10-19 152816.png)
    4. **구조 분해 할당**
       - 배열 또는 객체를 분해하여 속성을 변수에 쉽게 할당할 수 있는 문법
       - ![화면 캡처 2022-10-19 152852](C:.\화면 캡처 2022-10-19 152852.png)
    5. **객체 전개 구문 (Spread Operator)**
       - 배열과 마찬가지로 전개구문을 사용해 객체 내부에서 객체 전개 가능하다.
       - 얕은 복사에 활용 가능하다.
       - ![화면 캡처 2022-10-19 152932](C:.\화면 캡처 2022-10-19 152932.png)
    6. **JavaScriptON (JavaScript Object Notation)**
       - JSON
       - key - value 형태로 이루어진 자료 표기법
       - JavaScript의 Object와 유사한 구조를 가지고 있지만 Object는 그 자체로 타입이고, JavaScriptON은 형식이 있는 **문자열**
       - **즉, JavaScriptON을 Object로 사용하기 위해서는 변환 작업이 필요하다.**
       - ![화면 캡처 2022-10-19 153206](C:.\화면 캡처 2022-10-19 153206.png)
       - ![화면 캡처 2022-10-19 153237](C:.\화면 캡처 2022-10-19 153237.png)

---

## 4. Class

- ### class 정의

  - 함수와 마찬가지로 class 문법도 class 표현식, class 선언 두 가지 방법이 있다.

  

  - **class 선언**
    - class + 클래스의 이름으로 class를 정의한다.
    - ![화면 캡처 2022-10-21 092150](C:.\화면 캡처 2022-10-21 092150.png)
    - **호이스팅**
      - 클래스는 함수와 다르게 반드시 정의한 뒤에 사용할 수 있다.
      - 클래스는 호이스팅될 때 초기화 되지 않기 때문이다.
      - ![화면 캡처 2022-10-21 092302](C:.\화면 캡처 2022-10-21 092302.png)

  

  - **class 표현식**
    - Class 표현식은 이름을 가질 수도 있고 갖지 않을 수도 있다.
    - 이름을 가진 class 표현식의 이름은 클래스 body의 local scope에 한해서 유효하다. (하지만, 클래스의 name 속성을 통해 찾을 수 있다.)
    - ![화면 캡처 2022-10-21 092517](C:.\화면 캡처 2022-10-21 092517.png)



- ### Class body와 메서드 정의

  - **Class body**

    - Class body는 중괄호 {}로 묶여 있는 안쪽 부분이다.
    - 메서드나 constructor와 같은 class 맴버를 정의하는 곳이다.

    

    - **Strict mode**

      - 클래스의 본문 (body)은 strict mode에서 실행된다.
      - 성능 향상을 위해 더 엄격한 문법이 적용된다.

      

    - **Constructor (생성자)**

      - constructor 메서드는 class로 생성된 객체를 생성하고 초기화하기 위한 특수한 메서드
      - 클래스 안에 한 개만 존재할 수 있다.
      - 여러 개의 constructor 메서드가 존재하면 SyntaxError가 발생한다.
      - **부모 클래스의 constructor를 호출하기 위해 super 키워드를 사용할 수 있다.**
      - ![화면 캡처 2022-10-21 150517](C:.\화면 캡처 2022-10-21 150517.png)

    

    - **프로토타입 메서드**
      - ![화면 캡처 2022-10-21 152857](C:.\화면 캡처 2022-10-21 152857.png)

    

    - **메서드**

      - **단축 생성기 메서드**
        - 생성기 메서드는 단축 구문을 사용해서도 정의될 수 있다.
        - 단축 구문 내 **별표(*)는 생성기 속성명 앞**에 와햐 한다.
        - ![화면 캡처 2022-10-21 150845](C:.\화면 캡처 2022-10-21 150845.png)

      

      - **메서드 정의는 생성 불가능**
        - 모든 메서드 정의는 생성자가 아니고 인스턴스화 하는 경우  TypeError 예외가 발생한다.
        - ![화면 캡처 2022-10-21 151307](C:.\화면 캡처 2022-10-21 151307.png)
        - ![화면 캡처 2022-10-21 151327](C:.\화면 캡처 2022-10-21 151327.png)

      

      - **속성 계산명**
        - 단축 구문은 속성 계산명도 지원한다.
        - ![화면 캡처 2022-10-21 151429](C:.\화면 캡처 2022-10-21 151429.png)

    

    - **정적 메서드와 속성**
      - static 키워드는 클래스를 위한 정적 메서드를 정의한다.
      - 정적 메서드는 클래스의 인스턴스화 없이 호출되며, 클래스의 인스턴스에서는 호출할 수 없다.
      - **정적 메서드**
        - 어플리케이션을 위한 유틸리티 함수를 생성하는 데 주로 사용된다.
      - **정적 속성**
        - 캐시, 고정 환경설정 또는 인스턴스 간에 복제할 필요가 없는 기타 데이터에 유용하다.
      - ![화면 캡처 2022-10-21 153514](C:.\화면 캡처 2022-10-21 153514.png)

    

    - **프로토 타입 및 정적 메서드를 사용한 this 바인딩**
      - 정적 메서드나 프로토타입 메서드가 this 값 없이 호출될 때, this 값은 메서드 안에서 undefined가 된다.























































































































