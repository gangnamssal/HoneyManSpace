# Django : Form/Model Form 실습

## 1. Django form

- **개요**

> - 사용자가 입역한 데이터가 우리가 원하는 데이터 형식이 맞는지에 대한 유효성 검증이 반드시 필요하다.
>   - 이러한 유효성 검증은 많은 부가적인 것들을 고려해서 구현해야 하는데, 이는 개발 생산성을 늦추고 쉽지 않은 작업이다.
> - Django Form은 이 과정에서 과중한 작업과 반복 코드를 줄여준다.



- **Form Class**

> - **Form Class 선언**
>   - Form Class를 선언하는 것은 Model Class를 선언하는 것과 비슷한다.
>   - 비슷한 이름의 필드 타입을 많이 가지고 있다.
>   - Model과 마찬가지로 상속을 통해 선언한다.
>   - ![화면 캡처 2022-09-06 090852](C:.\화면 캡처 2022-09-06 090852.png)
> - ![화면 캡처 2022-09-06 090950](C:.\화면 캡처 2022-09-06 090950.png)
>   - ![화면 캡처 2022-09-06 091552](C:.\화면 캡처 2022-09-06 091552.png)
>   - ![화면 캡처 2022-09-06 092152](C:.\화면 캡처 2022-09-06 092152.png)
> - **Form rendering options**
>   - <lable> & <input> 쌍에 대한 3가지 출력 옵션
>     1. as_p()
>        - 각 필드가 단락(p태그)으로 감싸져서 렌더링
>     2. as_ul()
>        - 각 필드가 목록 항목(li 태그)으로 감싸져서 렌더링
>        - ul 태그는 직접 작성해야 한다.
>     3. as_table()
>        - 각 필드가 테이블(tr 태그) 행으로 감싸져서 렌더링
> - **HTML input 요소 표현**
>   - 1. Form fields
>        - 입력에 대한 유효성 검사 로직을 처리
>        - 템플릿에서 직접 사용된다.
>        - ![화면 캡처 2022-09-06 093116](C:.\화면 캡처 2022-09-06 093116.png)
>     2. Widgets
>        - 웹 페이지의 HTML input 요소 렌더링을 담당
>          - input 요소의 단순한 출력 부분을 담당
>        - Widgets은 반드시 form fields에 할당된다.
>        - ![화면 캡처 2022-09-06 093143](C:.\화면 캡처 2022-09-06 093143.png)



- **Widgets**

>- **개요**
>  - Django의 HTML input element의 표현을 담당
>  - **단순히 HTML 렌더링을 처리하는 것이며 유효성 검증과 아무런 관계가 없다.**
>    - 웹 페이지에서 input element의 단순 raw한 렌더링만을 처리하는 것일 뿐이다.
>  - ![화면 캡처 2022-09-06 093722](C:.\화면 캡처 2022-09-06 093722.png)
>  - ![화면 캡처 2022-09-06 093722](C:\Users\GNSS\Desktop\git\필기\Django\화면 캡처 2022-09-06 093923.png)

---

## 2. Django ModelForm

- **개요**

> - ModelForm을 사용하면 Form을 더 쉽게 작성할 수 있다.



- **ModelForm Class**

> - Model을 통해 Form Class를 만들 수 있는 helper class
> - ModelForm은 Form과 똑같은 방식으로 View 함수에서 사용한다.



- **ModelForm 선언**

> - forms 라이브러리에서 파생된 ModelForm 클래스를 상속받는다.
> - 정의한 ModelForm 클래스 안에 Meta 클래스를 선언한다.
> - **어떤 모델을 기반으로** form을 작성할 것인지에 대한 정보를 Meta 클래스에 지정
> - ![화면 캡처 2022-09-06 094814](C:.\화면 캡처 2022-09-06 094814.png)
> - **Meta Class**
>   - ModelForm의 **정보를 작성하는 곳**
>   - ModelForm을 사용할 경우 참조 할 모뎅이 있어야 하는데, **Meta class의 model 속성이 이를 구성.**
>     - 참조하는 모델에 정의된 field 정보를 Form에 적용
>     - ![화면 캡처 2022-09-06 094814](C:.\화면 캡처 2022-09-06 100108.png)
>   - fields 속성에 '____all____'를 사용하여 모델의 입력 받아야 하는 모든 필드를 포함할 수 있다.
>   - exclude 속성을 사용하여 모델에서 포함하지 않을 필드를 지정할 수 있다.
>   - ![화면 캡처 2022-09-06 100319](C:.\화면 캡처 2022-09-06 100319.png)
> - **Meta data**
>   - 데이터를 표현하기 위한 데이터
>   - ex. 사진 파일 (사진 데이터, 사진 데이터의 데이터(촬영 시각, 렌즈...))
> - **참조 값과 반환 값**
>   - ![화면 캡처 2022-09-06 100817](C:.\화면 캡처 2022-09-06 100817.png)
>   - 참조 값을 사용하는 경우
>     - ![화면 캡처 2022-09-06 101041](C:.\화면 캡처 2022-09-06 101041.png)



- **ModelForm view functions**

> - **CREATE**
>   - 유효성 검사를 **통과하면 데이터 저장**하고 상세 페이지로 redirect
>   - 유효성 검사를 **통과하지 못하면** 작성 페이지로 redirect
>   - ![화면 캡처 2022-09-06 101612](C:.\화면 캡처 2022-09-06 101612.png)
>   - **is_valid  method**
>     - **유효성 검사를 실시하고 데이터가 유효한지 여부를 boolean으로 반환**
>   - **errors 속성**
>     - is_valid()의 반환 값이 False인 경우 form 인스턴스의 errors 속성에 값이 작성, 유효성 검증을 실패한 원인이 딕셔너리 형태로 저장
>     - ![화면 캡처 2022-09-06 101909](C:.\화면 캡처 2022-09-06 101909.png)
>     - ![화면 캡처 2022-09-06 102252](C:.\화면 캡처 2022-09-06 102252.png)
>   - **save() method**
>     - form 인스턴스에 바인딩 된 데이터를 통해 데이터 베이스 객체를 만들고 저장
>     - ModelForm의 하위 클래스는 키워드 인자 instance 여부를 통해 생성할 지, 수정할 지를 결정
>       - 제공되지 않은 경우 save()는 지정된 모델의 새 인스턴스를 만듦(CREATE)
>       - 제공되면 save()는 해당 인스턴스를 수정(UPDATE)
>       - ![화면 캡처 2022-09-06 110206](C:.\화면 캡처 2022-09-06 110206.png)
>
> - **UPDATE**
>   - ModelForm의 인자 instance는 수정 대상이 되는 객체(기존 객체)를 지정
>   - 1. **request.POST**
>        - 사용자가 form을 통해 전송한 데이터 (새로운 데이터)
>     2. **instance**
>        - 수정이 되는 대상
>   - ![화면 캡처 2022-09-06 110349](C:.\화면 캡처 2022-09-06 110349.png)
>   - ![화면 캡처 2022-09-06 110445](C:.\화면 캡처 2022-09-06 110445.png)
>   - ![화면 캡처 2022-09-06 110539](C:.\화면 캡처 2022-09-06 110539.png)



- **Form과 ModelForm**

> - ModelForm이 Form보다 더 좋은 것이 아니라 각자 역할이 다르다.
> - **Form**
>   - 사용자로부터 받는 데이터가 **DB와 연관되어 있지 않는 경우에 사용**
>   - DB에 영향을 미치지 않고 단순 데이터만 사용되는 경우
>   - ex. 로그인
> - **ModelForm**
>   - 사용자로부터 받는 데이터가 **DB와 연관되어 있는 경우에 사용**
>   - 데이터의 유효성 검사가 끝나면 데이터를  각각 어떤 레코드에 맵핑해야 할지 이미 알고 있기 때문에 곧바로 save() 호출이 가능하다.



- **Widgets 활용하기**

>- ![화면 캡처 2022-09-06 112915](C:.\화면 캡처 2022-09-06 112915.png)
>  - 오른쪽을 권장
>- ![화면 캡처 2022-09-06 113032](C:.\화면 캡처 2022-09-06 113032.png)
>
>​	

---

## 3. Handling HTTP requests

- **개요**

> - HTTP requests 처리에 따른 view 함수 구조 변화
> - new-create, edit-update의 view 함수 역할의 공통점, 차이점
> - **공통점**
>   - new-create는 모두 CREATE 로직을 구현하기 위한 공통 목적
>   - edit-update는 모두 UPDATE 로직을 구현하기 위한 공통 목적
> - **차이점**
>   - new와 edit는 GET 요청에 대한 처리만을, create와 update는 POST 요청에 대한 처리만을 진행한다.



- **Create**

> - 1. **new와 create view 함수를 합친다.**
>   - 각각의 역할은 request.method 값을 기준으로 나뉜다.
>      
>   - ![화면 캡처 2022-09-06 133429](C:.\화면 캡처 2022-09-06 133429.png)
>      
>2. **불필요해진 new의 view함수와 url path를 삭제한다**
>      - ![화면 캡처 2022-09-06 135734](C:.\화면 캡처 2022-09-06 135734.png)
>   
>   3. **new.html -> create.html로 이름을 변경하고 action 속성 값을 수정한다.**
>   - ![화면 캡처 2022-09-06 135836](C:.\화면 캡처 2022-09-06 135836.png)
>      
>4. **템플릿 경로 수정**
>      - ![화면 캡처 2022-09-06 135944](C:.\화면 캡처 2022-09-06 135944.png)
>   
>   5. **new 관련 링크 수정**
>- ![화면 캡처 2022-09-06 140033](C:.\화면 캡처 2022-09-06 140033.png)



- **Update**

> - 1. **edit과 update view 함수를 합친다.**
>      - ![화면 캡처 2022-09-06 141131](C:.\화면 캡처 2022-09-06 141131.png)
>   2. 불필요해진 edit의 view 함수와 url path를 삭제
>      - ![화면 캡처 2022-09-06 141244](C:.\화면 캡처 2022-09-06 141244.png)
>   3. edit.html -> update.html 이름 변경으로 인한 정보 수정
>      - ![화면 캡처 2022-09-06 141345](C:.\화면 캡처 2022-09-06 141345.png)
>      - ![화면 캡처 2022-09-06 141421](C:.\화면 캡처 2022-09-06 141421.png)



- **Delete**

> - 1. POST 요청에 대해서만 삭제가 가능하도록 수정
>
> - ![화면 캡처 2022-09-06 141518](C:.\화면 캡처 2022-09-06 141518.png)

---

## 4. View decorators

- **데코레이터**

> - 기존에 작성된 함수에 기능을 추가하고 싶을 때, 해당 함수를 수정하지 않고 가능을 추가해주는 함수



- **Allowed HTTP methods**

> - django.views.decorators.http의 데코레이터를 사용하여 요청 메서드를 기반으로 접근을 제한할 수 있다.
> - 일치하지 않는 메서드 요청은 405 Method Not Allowed를 반환
>   - 405 Method Not Allowed : 요청 방법이 서버에게 전달 되었으나 사용 불가능한 상태
> - **목록** 
>   1. requre_http_methods()
>   2. require_POST()
>   3. require_safe()



- **require_http_methods()**

> - View 함수가 특정한 요청 method만 허용하도록 하는 데코레이터
> - ![화면 캡처 2022-09-06 145638](C:.\화면 캡처 2022-09-06 145638.png)



- **require_POST()**

> - View 함수가 POST 요청 method만 허용하도록 하는 데코레이터
> - ![화면 캡처 2022-09-06 145744](C:.\화면 캡처 2022-09-06 145744.png)



- **require_safe()**

> - require_GET이 있지만 Django에서는 require_safe를 사용하는 것을 권장
> - ![화면 캡처 2022-09-06 145902](C:.\화면 캡처 2022-09-06 145902.png)

---

## 5. Rendering fields manually

- 공식문서의 django form -> working with form template 메뉴 -> rendering fields manually를 참고



























