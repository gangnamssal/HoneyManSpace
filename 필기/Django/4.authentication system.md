# authentication system

## 1. The Django authentication system

- **개요**

> - **인증 시스템은 인증과 권한 부여를 함께 제공(처리)**
> - 필수 구성은 settings.py에 이미 포함되어 있다. (django.contrib.auth)
> - **Authentication(인증)**
>   - 신원 확인
>   - 사용자가 자신이 누구인지 확인하는 것
> - **Authorization(권한, 허가)**
>   - 권한 부여
>   - 인증된 사용자가 수행할 수 있는 작업을 결정



- **사전 설정**

> - 두번째 app accounts 생성 및 등록
> - ![화면 캡처 2022-09-07 132815](C:.\화면 캡처 2022-09-07 132815.png)
> - url 분리 및 매핑
> - ![화면 캡처 2022-09-07 132848](C:.\화면 캡처 2022-09-07 132848.png)



- **User 모델 대체하기**

>- **대체하기**
>
>  - AbstractUser를 상속받는 커스텀 User 클래스 작성
>
>  - ![화면 캡처 2022-09-07 133240](C:.\화면 캡처 2022-09-07 133240.png)
>
>    
>
>  - Django 프로젝트에서 User를 나타내는데 사용하는 모델을 방금 생성한 커스텀 User 모델로 지정
>
>  - ![화면 캡처 2022-09-07 133331](C:.\화면 캡처 2022-09-07 133331.png)
>
>    
>
>  - admin.py에 커스텀 User 모델을 등록
>
>    - 기본 user 모델이 아니기 떄문에 등록하지 않으면 admin site에 출력되지 않는다.
>    - ![화면 캡처 2022-09-07 133429](C:.\화면 캡처 2022-09-07 133429.png)
>
>    
>
>  - **참고**
>
>    - user 모델 상속 관계
>    - ![화면 캡처 2022-09-07 133529](C:.\화면 캡처 2022-09-07 133529.png)
>
>    
>
>    - ![화면 캡처 2022-09-07 135206](C:.\화면 캡처 2022-09-07 135206.png)
>
>    
>
>    - 추상 기본 클래스
>    - ![화면 캡처 2022-09-07 133638](C:.\화면 캡처 2022-09-07 133638.png)
>
>    
>
>  - **데이터베이스 초기화**
>
>    - ![화면 캡처 2022-09-07 134906](C:.\화면 캡처 2022-09-07 134906.png)
>    - ![화면 캡처 2022-09-07 135027](C:.\화면 캡처 2022-09-07 135027.png)

---



## 2. HTTP Cookies

- **HTTP**

> - Hyper Text Transfer Protocol
> - HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜(규칙, 규약)
> - 웹에서 이루어지는 모든 데이터 교환의 기초
> - 클라이언트-서버 프로토콜이라고도 부름
>
> 
>
> - **요청(requests)**
>   - 클라이언트(브라우저)에 의해 전송되는 메시지
> - **응답(response)**
>   - 서버에서 응답으로 전송되는 메시지
> - **HTTP 특징**
>   - 1. 비 연결 지향(connectionless)
>        - 서버는 요청에 대한 응답을 보낸 후 연결을 끊는다.
>     2. 무상태(stateless)
>        - 연결을 끊는 순간 클라이언트와 서버 간의 통신이 끝나며 상태 정보가 유지되지 않는다.
>        - 클라이언트와 서버가 주고받는 메시지들은 서로 완전히 독립적이다.



- **쿠키(cookie)**

> - HTTP 쿠키는 상태가 있는 세션을 만들도록 해준다.
> - 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각
> - 브라우저는 쿠키를 로컬에 KEY-VALUE의 데이터 형식으로 저장한다.
> - 동일한 서버에 재요청 시 저장된 쿠키를 함께 전송한다.
>
> 
>
> - **사용 목적**
>   - 1. 세션 관리
>        - 로그인, 아이디 자동완성 등의 정보 관리
>     2. 개인화
>        - 사용자 선호, 테마 등의 설정
>     3. 트래킹
>        - 사용자 행동을 기록 및 분석
> - **쿠키 수명(Lifetime)**
>   - 1. Session cookie
>        - 현재 세션이 종료되면 삭제된다.
>        - 브라우저 종료와 함께 세션이 삭제된다.
>     2. Persistent cookies
>        - Expires 속성에 지정된 날짜 혹은 Max-Age 속성에 지정된 기간이 지나면 삭제된다.



- **세션(Session)**

> - 사이트와 특정 브라우저 사이의 state(상태)를 유지시키는 것
> - 클라이언트가 서버에 접속하면 서버가 특정 session id를 발급하고 클라이언트는 session id를 쿠키에 저장
>   - 클라이언트가 다시 동일한 서버에 접속하면 요청과 함께 쿠키(session id)를 서버에 전달
>   - 쿠키는 요청 때마다 서버에 함께 전송되므로 서버에서 session id를 확인해 알맞은 로직을 처리
> - session id는 세션을 구별하기 위해 필요, 쿠키에는 session id만 저장

---



## 3. Authentication in Web requests

- **Login**

> - 로그인은 Session을 Create하는 과정이다.
>
> 
>
> - **AuthenticationForm**
>   - 로그인을 위한 built-in-form
>   - 로그인 하고자 하는 사용자 정보를 입력 받는다.
>   - 기본적으로 username과 password를 받아 데이터가 유효한지 검증한다.
>   - request를 첫번째 인자로 취한다.
>
> 
>
> - **로그인 페이지 작성**
>   - ![화면 캡처 2022-09-07 141301](C:.\화면 캡처 2022-09-07 141301.png)
>
> 
>
> - **login()**
>   - login(request,user,backend=None)
>   - 인증된 사용자를 로그인 시키는 로직으로 view 함수에서 사용된다.
>   - 현재 세션에 연결하려는 인증된 사용자가 있는 경우 사용한다.
>   - HttpRequest객체와 User 객체가 필요하다.
>   - ![화면 캡처 2022-09-07 141511](C:.\화면 캡처 2022-09-07 141511.png)
>
> 
>
> - **get_user()**
>   - AuthenticationForm의 인스턴스 메서드
>   - 유효성 검사를 통과했을 경우 로그인 한 사용자 객체를 반환한다.
> - **세션 데이터 확인하기**
>   - 1. django_session 테이블에서 확인
>     2. 브라우저에서 확인
>        - 개발자도구 - Application- Cookies



- **Logout**

> - 로그아웃은 Session을 Delete하는 과정이다.
>
> - **logout()**
>  - logout(request)
>   - HttpRequest 객체를 인자로 받고 반환 값이 없다.
>   - 사용자가 로그인하지 않은 경우 오류를 발생시키지 않는다.
>   - **다음 2가지 일을 처리**
>     1. 현재 요청에 대한 session data를 DB에서 삭제
>     2. 클라이언트의 쿠키에서도 session id를 삭제
>        - 다른 사람이 동일한 웹 브라우저를 사용하여 로그인하고, 이전 사용자의 세션 데이터에 접근하는 것을 방지하기 위함
> 
>
>   
>- **로그아웃 로직 작성하기**
> - ![화면 캡처 2022-09-07 143631](C:.\화면 캡처 2022-09-07 143631.png)

---



## 4. Authentication wiht User

- **개요**

> - 템플릿에서 인증 관련 데이터를 출력하는 방법
> - **현재 로그인 되어있는 유저 정보 출력하기**
>   - ![화면 캡처 2022-09-07 142855](C:.\화면 캡처 2022-09-07 142855.png)
>   - **settings.py의 context processors 설정 값 때문에 base 템플릿에서 context 데이터 없이 user 변수를 사용할 수 있다.**
>   - ![화면 캡처 2022-09-07 143243](C:.\화면 캡처 2022-09-07 143243.png)
>
> 
>
> - **context processors**
>   - 템플릿이 렌더링 될 때 호출 가능한 컨텍스트 데이터 목록
>   - 작성된 컨텍스트 데이터는 기본적으로 템플릿에서 사용 가능한 변수로 포함된다.
>   - ![화면 캡처 2022-09-07 143127](C:.\화면 캡처 2022-09-07 143127.png)



- **회원 가입**

> - 회원가입은 User를 Create하는 것이며 **UserCreationForm** built-in-form을 사용한다.
> - **UserCreationForm**
>   - 주어진 username과 password로 권한이 없는 새 user를 생성하는 ModelForm
>   - 3개의 필드를 가진다.
>     - 1. username(from the user model)
>       2. password1
>       3. password2
> - **회원 가입 페이지 작성**
>   - ![화면 캡처 2022-09-07 143935](C:.\화면 캡처 2022-09-07 143935.png)
>   - ![화면 캡처 2022-09-07 144025](C:.\화면 캡처 2022-09-07 144025.png)
>   - **UserCreationForm이 우리가 대체한 커스텀 유저 모델이 아닌 기존 유저 모델로 인해 작성된 클래스이기 때문에 에러가 난다.**



- **custom user & built-in auth forms**

> - custom user와 기존 built-in auth forms 간의 관계
> - custom user로 인한 built-in auth forms 변경
>
> ![화면 캡처 2022-09-07 144308](C:.\화면 캡처 2022-09-07 144308.png)
>
> ![화면 캡처 2022-09-07 144356](C:.\화면 캡처 2022-09-07 144356.png)
>
> 
>
> - **커스텀 하기**
>
>   - ![화면 캡처 2022-09-07 144432](C:.\화면 캡처 2022-09-07 144432.png)
>
>     
>
>   - **형식 추가하기**
>
>     - fields = UserCreationForm.metafields + ('email',)
>     - 단, 추가하는 필드가 존재하는 필드여야 한다.
>
>     
>
>   - ![화면 캡처 2022-09-07 144525](C:.\화면 캡처 2022-09-07 144525.png)
>
>     
>
>   - ![화면 캡처 2022-09-07 144639](C:.\화면 캡처 2022-09-07 144639.png)
>
>   
>
> - **회원가입 후 바로 로그인 하기**
>
>   - ![화면 캡처 2022-09-07 144758](C:.\화면 캡처 2022-09-07 144758.png)
>   - ![화면 캡처 2022-09-07 144842](C:.\화면 캡처 2022-09-07 144842.png)



- **회원 탈퇴**

> - 회원 탈퇴하는 것은 DB에서 유저를 Delete하는 것과 같다.
> - **회원 탈퇴 로직 작성**
>   - ![화면 캡처 2022-09-07 145009](C:.\화면 캡처 2022-09-07 145009.png)
>   - ![화면 캡처 2022-09-07 145048](C:.\화면 캡처 2022-09-07 145048.png)



- **회원정보 수정**

> - 회원정보 수정은 user를 Update 하는 것이며 **UserChageForm** built-in form을 사용한다.
>
>   
>
> - **UserChageForm**
>
>   - 사용자의 정보 및 권한을 변경하기 위해 admin 인터페이스에서 사용되는 ModelForm
>   - UserChageForm 또한 ModelForm이기 때문에 instance 인자로 기존 user 데이터 정보를 받는 구조 또한 동일하다.
>   - 확장한 CustomUserChageForm을 사용하기
>
>   
>
> - **회원정보 수정 페이지 작성**
>
>   - ![화면 캡처 2022-09-07 145941](C:.\화면 캡처 2022-09-07 145941.png)
>
>   
>
> - **UserChageForm 사용 시 문제점**
>
>   - 일반 사용자가 접근해서는 안 될 정보들(fields)까지 모두 수정이 가능해진다.
>     - admin 인터페이스에서 사용되는 ModelForm이기 때문이다.
>   - 따라서 UserChageForm을 상속받아 작성해 두었던 서브 클래스 CustomUserChageForm에서 접근 가능한 필드를 조정해야 한다.
>
> 
>
> - **CustomUserChageForm 재정의**
>   - ![화면 캡처 2022-09-07 150237](C:.\화면 캡처 2022-09-07 150237.png)
>   - ![화면 캡처 2022-09-07 150310](C:.\화면 캡처 2022-09-07 150310.png)
>
> 
>
> - **회원정보 수정 로직 작성**
>   - ![화면 캡처 2022-09-07 150418](C:.\화면 캡처 2022-09-07 150418.png)



- **비밀번호 변경**

> - **PasswordChageForm**
>
>   - 사용자가 비밀번호를 변경할 수 있도록 하는 Form
>   - 이전 비밀번호를 입력하여 비밀번호를 변경할 수 있도록 한다.
>   - **이전 비밀번호를 입력하지 않고 비밀번호를 설정할 수 있는 SetPasswordForm**을 상속받는 서브 클래스
>
>   
>
> - **비밀번호 변경 페이지 작성**
>
>   - ![화면 캡처 2022-09-07 150637](C:.\화면 캡처 2022-09-07 150637.png)
>
>   
>
> - **비밀번호 변경 로직 작성**
>
>   - 변경 후 로그인 상태가 지속되지 못하는 문제가 발생한다.
>   - ![화면 캡처 2022-09-07 150728](C:.\화면 캡처 2022-09-07 150728.png)
>
>   
>
> - **암호 변경 시 세션 무효화 방지하기**
>
>   - 비밀번호가 변경되면 기존 세션과의 회원 인증 정보가 일치하지 않게 되어 버려 로그인 상태가 유지되지 못한다.
>   - 비밀번호는 잘 변경되었으나 비밀번호가 변경 되면서 기존 세션과의 회원 인증 정보가 일치하지 않기 때문이다.
>   - **update_session_auth_hash()**
>     - update_session_auth_hash(request, user)
>     - 현재 요청과 새 session data가 파생 될 업데이트 된 사용자 객체를 가져오고, session data를 적절하게 업데이트 해준다.
>     - 암호가 변경되어도 로그아웃 되지 않도록 새로운 password의 session data로 session을 업데이트
>     - ![화면 캡처 2022-09-07 151700](C:.\화면 캡처 2022-09-07 151700.png)

---



## 5. Limiting access to logged-in users

- **개요**

> - 로그인 사용자에 대한 접근 제한하기
> - 2가지 방법
>   - 1. The raw way
>        - **is_authenticated** (attribute)
>     2. The **login_required** (decorator)



- **is_authenticated**

> - User model의 속성 중 하나
> - 사용자가 인증 되었는지 여부를 알 수 있는 방법
> - 모든 User 인스턴스에 대해 항상 True인 읽기 전용 속성
>   - AnonymousUser(로그인 하지 않은 유저)에 대해서는 항상 False
> - 일반적으로 **reuest.user**에서 이 속성을 사용한다. (**request.user.is_authenticated**)
> - **권한과는 관련이 없으며, 사용자가 활성화 상태이거나 유효한 세션을 가지고 있는지도 확인하지 않는다.**
> - ![화면 캡처 2022-09-07 152429](C:.\화면 캡처 2022-09-07 152429.png)
>
> 
>
> - **적용하기**
>
>   - 로그인과 비로그인 상태에서 출력되는 링크를 다르게 설정하기
>   - ![화면 캡처 2022-09-07 152522](C:.\화면 캡처 2022-09-07 152522.png)
>
>   
>
>   - 인증된 사용자만 게시글 작성 링크를 볼 수 있도록 처리하기
>   - 아직 비로그인 상태로도 URL을 직접 입력하면 게시글 작성 페이지로 갈 수 있다.
>   - ![화면 캡처 2022-09-07 152628](C:.\화면 캡처 2022-09-07 152628.png)
>
>   
>
>   - 인증된 사용자라면 로그인 로직을 수행할 수 없도록 처리
>   - ![화면 캡처 2022-09-07 152706](C:.\화면 캡처 2022-09-07 152706.png)



- **login_required**

> - login_required decorator
>
> - 사용자가 로그인 되어 있으면 정상적으로 view 함수를 실행
>
> - 로그인 하지 않은 사용자의 경우 settings.py의 LOGIN_URL 문자열 주소로 redirect
>
>   - LOGIN_URL의 기본 값은 /accounts/login/
>   - 두번째 app 이름을 accounts로 했던 이유 중 하나이다.
>
>   
>
> - **login_requred**
>
>   - 로그인 상태에서만 글을 작성/ 수정/ 삭제 할 수 있도록 변경
>   - ![화면 캡처 2022-09-07 152923](C:.\화면 캡처 2022-09-07 152923.png)
>   - ![화면 캡처 2022-09-07 152957](C:.\화면 캡처 2022-09-07 152957.png)
>
>   
>
> - **''next'' query string parameter**
>
>   - 로그인이 정상적으로 진행되면 이전에 요청했던 주소로 redirect 하기 위해 Django가 제공해주는 쿼리 스트링 파라미터
>
>   - 해당 값을 처리할지 말지는 자유, 별도로 처리 해주지 않으면 view에 설정한 redirect 경로로 이동
>
>     
>
>   - ![화면 캡처 2022-09-07 153139](C:.\화면 캡처 2022-09-07 153139.png)
>
>     
>
>   - ![화면 캡처 2022-09-07 153205](C:.\화면 캡처 2022-09-07 153205.png)
>
>     
>
>   - ![화면 캡처 2022-09-07 153318](C:.\화면 캡처 2022-09-07 153318.png)
>
>   
>
>   - ![화면 캡처 2022-09-07 153351](C:.\화면 캡처 2022-09-07 153351.png)
>   - ![화면 캡처 2022-09-07 153417](C:.\화면 캡처 2022-09-07 153417.png)
>   - ![화면 캡처 2022-09-07 153452](C:.\화면 캡처 2022-09-07 153452.png)
>   - ![화면 캡처 2022-09-07 153520](C:.\화면 캡처 2022-09-07 153520.png)