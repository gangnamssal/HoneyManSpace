# Model



## 1. Namespace

- **개요**
  - URL namespace를 사용하면 서로 다른 앱에서 동일한 URL 이름을 사용하는 경우에는 이름이 지정된 URL을 고유하게 사용할 수 있다.
  - ![화면 캡처 2022-08-31 090212](C:.\화면 캡처 2022-08-31 090212.png)
  - ![화면 캡처 2022-08-31 090105](C:.\화면 캡처 2022-08-31 090105.png)



- **URL 참조** 
  - ':' 연산자를 사용하여 지정
    - ex. app_name이 articles, URL name이 index인 주소 참조 articles : index
  - URL 참조와 template namespace를 같이 해주어야 한다.
  - **app_name을 지정한 이후에는 url 태그에서 반드시 app_name : url_name 형태로만 사용해야 한다. 그렇지 않으면 NoReverceMatch 에러가 발생한다.**
    - NoReverceMatch가 발생하면 url태그만 확인하면 된다.



- **Template namespace**
  - Django는 기본적으로 app_name/templates/경로에 있는 templates 파일들만 찾을 수 있으며, **settings.py의 INSTALLED_APPS에 작성한 app 등록 순서로 template을 검색 후 렌더링 한다.**
  - 바로 이 속성 값이 해당 경로를 활성화하고 있다.
  - ![화면 캡처 2022-08-31 092618](C:.\화면 캡처 2022-08-31 092618.png)
  - **디렉토리 생성을 통해 물리적인 이름공간 구분**
    - Django templates의 기본 경로에 app과 같은 이름의 폴더를 생성해 폴더 구조를 app_name/templates/app_name/의 형태로 변경
    - ![화면 캡처 2022-08-31 092959](C:.\화면 캡처 2022-08-31 092959.png)
    - Django templates의 기본 경로 자체를 변경할 수는 없기 때문에 물리적으로 이름 공간을 만드는 것이다.
    - ![화면 캡처 2022-08-31 093117](C:.\화면 캡처 2022-08-31 093117.png)
  - 만약 단일 앱으로만 이루어진 프로젝트라면 상관이 없다.
  - 여러 앱이 되었을 때에도 템플릿 파일 이름이 겹치지 않게 하면 되지만, 앱이 많아지면 대부분은 같은 이름의 템플릿 파일이 존재하기 때문에 사용한다.

---



## 2. Django Model

- **Database**
  - 체계화된 데이터의 모임
  - 검색 및 구조화 같은 작업을 보다 쉽게 하기 위해 조직화된 데이터를 수직하는 저장 시스템
  - **기본 구조**
    - **스키마 (Schema)**
      - 뼈대(structure)
      - 데이터베이스에서 자료의 구조, 표현 방법, 관계 등을 정의한 구조
      - ![화면 캡처 2022-08-31 094050](C:.\화면 캡처 2022-08-31 094050.png)
    - **테이블 (Table)**
      - 필드와 레코드를 사용해 조직된 데이터 요소들의 집합
        - **필드 (field)** 
          - 속성, 컬럼(Column)
          - 각 필드에서 고유한 데이터 형식이 지정된다. (INT, TEXT...)
        - **레코드 (record)** 
          - 튜플, 행 (Row)
          - 테이블의 데이터는 레코드에 저장된다.
      - 관계 (Relation) 라고도 부른다.
      - ![화면 캡처 2022-08-31 094328](C:.\화면 캡처 2022-08-31 094328.png)
      - **PK (Primary Key)**
        - 기본 키
        - 각 레코드의 고유한 값 (식별자로 사용)
        - 기술적으로 **다른 항목과 절대로 중복되어 나타날 수 없는 단일 값**을 가진다.
        - 데이터베이스 관리 및 테이블 간 관계 설정시 주요하게 활용된다.
        - ex. 주민등록번호
        - ![화면 캡처 2022-08-31 094749](C:.\화면 캡처 2022-08-31 094749.png)
      - **쿼리(Query)**
        - 데이터를 조회하기 위한 명령어를 일컬음
        - 조건에 맞는 데이터를 추출하거나 조작하는 명령어이다. (주로 테이블형 자료구조에서)
        - Query를 날린다 = 데이터베이스를 조작한다.



- **Model**
  - Django는 Model을 통해 데이터에 접속하고 관리
  - 단일한 데이터에 대한 정보를 가진다.
  - 사용자가 저장하는 데이터들의 필수적인 필드들과 동작들을 포함한다.
  - 저장된 데이터베이스의 구조 (layout)
  - 일반적으로 각각의 모델은 하나의 데이터베이스 테이블에 매핑 (하나의 값을 다른 값으로 대응시킨 것)
    - 모델 클래스 1개 == 데이터베이스 테이블 1개
  - ![화면 캡처 2022-08-31 095634](C:.\화면 캡처 2022-08-31 095634.png)
  - **작성하기**
    - 1. 새 프로젝트, 앱 작성 및 등록
      2. models.py 작성
         - 모델 클래스를 작성하는 것은 데이터베이스 테이블의 스키마를 정의하는 것
         - 모델 클래스 == 테이블 스키마
         - **PK(id) 는 자동으로 만들어준다.**
         - ![화면 캡처 2022-08-31 100736](C:.\화면 캡처 2022-08-31 100736.png)
  - **이해하기**
    - 각 모델은 **django.models.Model 클래스의 서브 클래스로 표현**된다.
      - 각 모델은 **django.db.models 모듈의 Model 클래스를 상속**받아 구성된다.
    - models 모듈을 통해 어떠한 타입의 DB 필드 (컬럼)을 정의할 것인지를 정의
      - **클래스 변수 title과 content은 DB 필드를 나타낸다.**
      - **클래스 변수 값은 DB필드의 데이터 타입을 나타낸다.**
        - **CharField(max_length=None, options)** : 길이가 제한된 문자열이라 반드시 길이를 정해주는 max_length가 있어야 한다. 데이터베이스와 django의 유효성 검사(값을 검증하는 것)에서 활용된다.
        - **TextField (options)** : 글자수가 많을 때 사용, 저장될 때 길이에 대한 유효성을 검증하지 않는다.
      - ![화면 캡처 2022-08-31 103424](C:.\화면 캡처 2022-08-31 103424.png)
    - **Django Model Field**
      - Django는 모델 필드를 통해 테이블의 필드(컬럼)에 저장할 데이터 유형(INT,TEXT 등)을 정의
      - 데이터 유형에 따라 다양한 모델 필드를 제공한다.



- **Migrations**
  - **makemigrations**
    - 모델을 작성 혹은 변경한 것에 기반한 새로운 migration(설계도, 청사진..)을 만들때 사용
    - 테이블을 만들기 위한 **설계도를 생성**하는 것
    - ![화면 캡처 2022-08-31 104355](C:.\화면 캡처 2022-08-31 104355.png)
    - ![화면 캡처 2022-08-31 104455](C:.\화면 캡처 2022-08-31 104455.png)
  - **migrate**
    - makemigrations로 만든 설계도를 실제 db.sqlite3 DB 파일에 반영하는 과정
    - 결과적으로 **모델에서의 변경사항들과 DB의 스키마가 동기화**를 이룬다.
      - **모델과 DB의 동기화**
    - ![화면 캡처 2022-08-31 104628](C:.\화면 캡처 2022-08-31 104628.png)
    - ![화면 캡처 2022-08-31 104712](C:.\화면 캡처 2022-08-31 104712.png)
    - **기타 명령어**
      - ![화면 캡처 2022-08-31 104821](C:.\화면 캡처 2022-08-31 104821.png)
      - ![화면 캡처 2022-08-31 104847](C:.\화면 캡처 2022-08-31 104847.png)
  
  
  
  - **DB 열어보기**
    - **확장프로그램 sqlite를 설치하고 db를 연다.**
    - **테이블 이름은 app_name_class_name으로 설정된다.**
    - ![화면 캡처 2022-08-31 112447](C:.\화면 캡처 2022-08-31 112447.png)
  
  
  
  - **Modele 변경사항 반영**
    - 기존에 테이블에 2개의 컬럼이 추가되는 상황
    - ![화면 캡처 2022-08-31 134136](C:.\화면 캡처 2022-08-31 134136.png)
      - **DateField를 상속받는 클래스**
        - **auto_now_add**
          - **최초 생성 일자**
          - Django ORM이 **최초 insert(테이블에 데이터 입력) 시에만 현재 날짜와 시간으로 갱신** (테이블에 어떤 값을 최초로 넣을 때)
        - **auto_now**
          - **최종 수정 일자**
          - Django ORM이 **save를 할 때마다 현재 날짜와 시간으로 갱신**
    - 기본적으로 빈 값으로 추가될 수 없다.
      - 그래서 우리에게 추가되는 컬럼에 대한 기본 값을 설정해야 하니 물어보는 과정
      - ![화면 캡처 2022-08-31 134309](C:.\화면 캡처 2022-08-31 134309.png)
      - 1) **다음 화면으로 넘어가서 새 컬럼의 기본 값을 직접 입력하는 방법**
        2) **현재 과정에서 나가고 모델 필드에 default 속성을 직접 작성하는 방법**
      - 1을 입력하고 다음 화면에서 Enter을 입력하면 파이썬의 timezone 모듈의 now 메서드 반환 값을 기본 값으로 사용하도록 해준다.
      - 새로운 설계도(마이그레이션 파일)가 만들어졌다.
        - **1번 설계도에서 추가로 만든 새로운 설계도는 의존성 가진다.**
        - **새로운 클래스(테이블)로 만든 설계도는 1번에 대한 의존성이 없다.**
        - ![화면 캡처 2022-08-31 135002](C:.\화면 캡처 2022-08-31 135002.png)
  - **해석을 담당하는 것이 ORM이다**
  
  
  
  - **migration 3단계**
    - 1. models.py에서 변경사항이 발생하면
      2. migrations 파일 생성 (설계도 생성)
         - makemigrations
      3. DB 반영 (모델과 DB의 동기화)
         - migrate



- **ORM (Object - Relational - Mapping)**
  - **개요**
    - 객체 지향 프로그래밍 언어를 사용하여 **호환되지 않는 유형의 시스템 간에 (Django <-> SQL) 데이터를 변환하는 프로그래밍 기술**
  - **장단점**
    - **장점**
      - SQL을 잘 알지 못해도 객체지향 언어로 DB 조작이 가능하다.
      - 객체 지향적 접근으로 인한 높은 생산성을 가진다.
    - **단점**
      - ORM 만으로 완전한 서비스를 구현하기 어려운 경우가 있다.

---



## 3. Queryset API

- **사전 준비**
  - ![화면 캡처 2022-08-31 140027](C:.\화면 캡처 2022-08-31 140027.png)
  - **IPython**
    - 파이썬 기본 쉘보다 더 강력한 파이썬 쉘
    - django-extensions
  - **django-extensions**
    - Django 확장 프로그램 모음, 다양한 확장 기능을 제공
  - **Shell**
    - 운영체제 상에서 다양한 기능과 서비스를 구현하는 인터페이스를 제공하는 프로그램
    - 사용자 <-> 셸 <-> 운영체제
    - **Python Shell**
      - 파이썬 코드를 실행해주는 인터프리터
      - 인터렉티브 혹은 대화형 shell이라고 부른다.
      - python 명령어를 실행하여 그 결과를 바로 제공한다.
  - **Django shell**
    - ORM 관련 구문 연습을 위해 파이썬 쉘 환경을 사용
    - 일반 파이썬 쉘을 통해서는 장고 프로젝트 환경에 영향을 줄 수 없기 때문에 Django환경 안에서 진행할 수 있는 Django 쉘을 사용한다.
    - ![화면 캡처 2022-08-31 141358](C:.\화면 캡처 2022-08-31 141358.png)
  - **첫 ORM 명령어 사용하기**
    - ![화면 캡처 2022-08-31 141609](C:.\화면 캡처 2022-08-31 141609.png)



- **QuerySet API**
  - Django가 기본적으로 ORM을 제공함에 따른 것으로 DB를 편하게 조작할 수 있도록 도움을 준다.
  - Model을 만들면 Django는 객체들을 만들고 읽고 수정하고 지울 수 있는 DB API를 자동으로 만듦
  - ![화면 캡처 2022-08-31 143328](C:.\화면 캡처 2022-08-31 143328.png)
  - **Objects manager**
    - django 모델이 데이터베이스 쿼리 작업을 가능하게 하는 인터페이스
    - django는 기본적으로 모든 django 모델 클래스에 대해 objects라는 Manager 객체를 자동으로 추가한다.
    - 이 manager(objects)를 통해 특정 데이터를 조작(메서드)할 수 있다.
    - **DB를 python class로 조작할 수 있도록 여러 메서드를 제공하는 manager**
  - **Query**
    - 데이터베이스에 특정한 데이터를 보여 달라는 요청
    - 파이썬으로 작성한 코드가 ORM의 의해 SQL로 변환되어 데이터베이스에 전달되며, 데이터베이스의 **응답 데이터를 ORM이 QuerySet이라는 자료 형태로 변환하여 우리에게 전달**
  - **QuerySet**
    - 데이터베이스에게서 받은 객체 목록 (데이터 모음)
      - 순회가 가능한 데이터로써 1개 이상의 데이터를 불러와 사용할 수 있다.
    - 필터를 걸거나 정렬 등을 수행할 수 있다.
    - objects manager를 사용하여 복수의 데이터를 가져오는 queryset method를 사용할 때 반환되는 객체
    - 데이터베이스가 단일한 객체를 반환 할 때는 Queryset이 아닌 모델(class)의 인스턴스로 변환된다.
  - ![화면 캡처 2022-08-31 143904](C:.\화면 캡처 2022-08-31 143904.png)

---



## 4. CRUD with view functions

- **Create/Read/Update/Delete**

  - 생성/조회/수정/삭제

- 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능 4가지를 일컫는 말이다.

- **Create**

  - **첫번째 방법**

    1. article = Article()

       - 클래스를 통한 인스턴스 생성

    2. article.title

       - 클래스 변수명과 같은 이름의 인스턴스 변수를 생성 후 값 할당

    3. article.save()

       - 인스턴스로 save 메서드 호출

       ![화면 캡처 2022-08-31 144344](C:.\화면 캡처 2022-08-31 144344.png)

       ![화면 캡처 2022-08-31 144536](C:.\화면 캡처 2022-08-31 144536.png)

       ![화면 캡처 2022-08-31 144759](C:.\화면 캡처 2022-08-31 144759.png)

  - **두번째 방법**

    - 인스턴스 생성 시 초기 값을 함께 작성하여 생성
    - ![화면 캡처 2022-08-31 144907](C:.\화면 캡처 2022-08-31 144907.png)

  - **세번째 방법**

    - ![화면 캡처 2022-08-31 145144](C:.\화면 캡처 2022-08-31 145144.png)

  

- **.save()**

  - 객체를 데이터베이스에 저장한다.
  - 데이터 생성 시 save를 호출하기 전에는 객체의 id값은 None
    - id 값은 django가 아니라 데이터베이스에서 계산되기 떄문이다.
  - 단순히 모델 클래스를 통해 인스턴스를 생성하는 것은 DB에 영향을 미치지 않기 때문에 반드시 save를 호출해야 테이블에 레코드가 생성된다.



- **READ**
  - **all()**
    - QuerySet return
    - 전체 데이터 조회
    - ![화면 캡처 2022-08-31 145546](C:.\화면 캡처 2022-08-31 145546.png)
  - **get()**
    - 단일 데이터 조회
    - 객체를 찾을 수 없으면 **DoesNotExist 예외를 발생**, 둘 이상의 객체를 찾으면 **MultipleObjectsReturned예외**를 발생시킴
    - **고유성(uniqueness)을 보장하는 조회에서 사용해야 한다.**
    - ![화면 캡처 2022-08-31 145723](C:.\화면 캡처 2022-08-31 145723.png)
  - **filter()**
    - 지정된 조회 매개 변수와 일치하는 객체를 포함하는 새 QuerySet을 반환
    - ![화면 캡처 2022-08-31 145820](C:.\화면 캡처 2022-08-31 145820.png)
  - **Field lookups**
    - 특정 레코드에 대한 조건을 설정하는 방법
    - QuerySet메서드 filter(), exclude(), get()에 대한 키워드 인자로 지정됨
    - ![화면 캡처 2022-08-31 150249](C:.\화면 캡처 2022-08-31 150249.png)



- **Update**
  - 수정하고자 하는 **article 인스턴스 객체를 조회 후 반환 값을 저장**한다.
  - article 인스턴스 객체의 인스턴스 변수 값을 새로운 값으로 할당
  - save() 인스턴스 메서드 호출
  - ![화면 캡처 2022-08-31 150638](C:.\화면 캡처 2022-08-31 150638.png)



- **Delete**
  - 삭제하고자 하는 article 인스턴스 객체를 조회 후 반환 값을 저장
  - delete() 인스턴스 메서드 호출
  - ![화면 캡처 2022-08-31 151301](C:.\화면 캡처 2022-08-31 151301.png)
  - **____str____()**
    - 표준 파이썬 클래스의 메서드인 str() 을 정의하여 각각의 object가 사람이 읽을 수 있는 문자열을 반환하도록 할 수 있음
    - ![화면 캡처 2022-08-31 151610](C:.\화면 캡처 2022-08-31 151610.png)
    - ![화면 캡처 2022-08-31 151838](C:.\화면 캡처 2022-08-31 151838.png)



- **CRUD with view functions**

  - **사전 준비**

    - ![화면 캡처 2022-08-31 152021](C:.\화면 캡처 2022-08-31 152021.png)
    - ![화면 캡처 2022-08-31 152052](C:.\화면 캡처 2022-08-31 152052.png)
    - ![화면 캡처 2022-08-31 152137](C:.\화면 캡처 2022-08-31 152137.png)

    

  - **READ1 (index page)**

    - **전체 게시글 조회**
    - ![화면 캡처 2022-08-31 152241](C:.\화면 캡처 2022-08-31 152241.png)

    

  - **CREATE**

    - ![화면 캡처 2022-08-31 152832](C:.\화면 캡처 2022-08-31 152832.png)
    - NEW(1/2)![화면 캡처 2022-08-31 152906](C:.\화면 캡처 2022-08-31 152906.png)
    - NEW(2/2)![화면 캡처 2022-08-31 152932](C:.\화면 캡처 2022-08-31 152932.png)
    - ![화면 캡처 2022-08-31 153027](C:.\화면 캡처 2022-08-31 153027.png)
    - ![화면 캡처 2022-08-31 153459](C:.\화면 캡처 2022-08-31 153459.png)
    - ![화면 캡처 2022-08-31 154043](C:.\화면 캡처 2022-08-31 154043.png)
    - ![화면 캡처 2022-08-31 154151](C:.\화면 캡처 2022-08-31 154151.png)
    - ![화면 캡처 2022-08-31 160939](C:.\화면 캡처 2022-08-31 160939.png)
    - ![화면 캡처 2022-08-31 161153](C:.\화면 캡처 2022-08-31 161153.png)
    - ![화면 캡처 2022-08-31 161230](C:.\화면 캡처 2022-08-31 161230.png)
    - ![화면 캡처 2022-08-31 161328](C:.\화면 캡처 2022-08-31 161328.png)
    - ![화면 캡처 2022-08-31 161401](C:.\화면 캡처 2022-08-31 161401.png)
    - **참고**
      - **302 Found**
        - HTTP response status code 중 하나
        - 해당 상태 코드를 응답 받으면 브라우저는 사용자를 해당 URL의 페이지로 이동 시킨다.
      - **HTTP response status code**
        - 클라이언트에게 특정 HTTP **요청이 성공적으로 완료되었는지 여부**를 알려준다.
        - 응답은 5개의 그룹으로 나뉘어진다.
        - ![화면 캡처 2022-08-31 161628](C:.\화면 캡처 2022-08-31 161628.png)
      - **HTTP method GET 재검토**
        - ![화면 캡처 2022-08-31 161821](C:.\화면 캡처 2022-08-31 161821.png)
      - **HTTP request method**
        - HTTP는 request method를 정의하며, 주어진 리소스에 수행하길 원하는 행동을 나타낸다.
        - **GET**
          - 특정 리소스를 가져오도록 요청할 때 사용한다.
          - **반드시 데이터를 가져올 떄만 사용해야 한다.**
          - DB에 변화를 주지 않는다.
          - CRUD에서 R 역할을 담당
        - **POST**
          - 서버로 데이터를 전송할 때 사용
          - 서버에 변경사항을 만든다.
          - 리소스를 생성/변경하기 위해 데이터를 HTTP body에 담아 전송한다.
          - GET의 쿼리 스트링 파타미터와 다르게 URL로 보내지지 않는다.
          - CRUD에서 C/U/D 역할을 담당
      - **POST method 적용하기**
        - ![화면 캡처 2022-08-31 162154](C:.\화면 캡처 2022-08-31 162154.png)
        - ![화면 캡처 2022-08-31 162228](C:.\화면 캡처 2022-08-31 162228.png)
        - ![화면 캡처 2022-08-31 162258](C:.\화면 캡처 2022-08-31 162258.png)
      - **403 Forbidden**
        - 서버에 요청이 전달되었지만, 권한 때문에 거절되었다는 것을 의미한다.
        - 서버에 요청은 도달했으나 서버가 접근을 거부할 때 반환
        - DB를 조작하는 것은 단순 조회와 달리 최소한의 신원 확인이 필요하기 때문이다.
      - **CSRF**
        - cross-site-request-forgery
        - 사이트 간 요청 위조
        - 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하여 특정 웹페이지를 보안에 취약하게 하거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법
        - **공격 방어**
          - Security Token 사용 방식 (CSRF token)
            - 사용자의 데이터에 임의의 난수 값(token)을 부여해 매 요청마다 해당 난수 값을 포함시켜 전송 시키도록 한다.
            - 이후 서버에서 요청을 받을 때마다 전달된 token 값이 유효한지 검증
            - 일반적으로 데이터 변경이 가능한 POST,PATCH,HELETE,Method 등에 적용
            - django 는 DLT에서 csrf_token 템플릿 태그를 제공한다.
            - ![화면 캡처 2022-08-31 163227](C:.\화면 캡처 2022-08-31 163227.png)
            - ![화면 캡처 2022-08-31 163321](C:.\화면 캡처 2022-08-31 163321.png)
            - ![화면 캡처 2022-08-31 163409](C:.\화면 캡처 2022-08-31 163409.png)

  - **READ 2**

    - 개별 게시글 상세 페이지 제작
    - 모든 게시글 마다 뷰 함수와 템플릿 파일을 만들 수는 없다.
      - 글의 번호(pk)를 활용해서 하나의 뷰 함수와 템플릿 파일로 대응
    - **urls**
      - ![화면 캡처 2022-08-31 164514](C:.\화면 캡처 2022-08-31 164514.png)
    - **views**
      - ![화면 캡처 2022-08-31 164554](C:.\화면 캡처 2022-08-31 164554.png)
    - **templates**
      - ![화면 캡처 2022-08-31 164803](C:.\화면 캡처 2022-08-31 164803.png)
    - **redirect 인자 변경**
      - ![화면 캡처 2022-08-31 165244](C:.\화면 캡처 2022-08-31 165244.png)

    

  - **DELETE**

    - **urls**
      - 모든 글을 삭제 하는 것이 아니라 삭제하고자 하는 특정 글을 조회 후 삭제해야 한다.
    - **views**
      - ![화면 캡처 2022-08-31 165429](C:.\화면 캡처 2022-08-31 165429.png)
    - **templates**
      - ![화면 캡처 2022-08-31 165541](C:.\화면 캡처 2022-08-31 165541.png)

    

  - **UPDATE**

    - 수정은 CREATE 로직과 마찬가지로 2개의 view 함수가 필요하다.
    - 사용자의 입력을 받을 페이지를 렌더링 하는 함수 1개
      - 'edit' view function
    - 사용자가 입력한 데이터를 전송 받아 DB에 저장하는 함수 1개
      - 'update' view function
    - **Edit-urls & views**
      - ![화면 캡처 2022-08-31 172932](C:.\화면 캡처 2022-08-31 172932.png)
    - **Edit-templates**
      - ![화면 캡처 2022-08-31 173026](C:.\화면 캡처 2022-08-31 173026.png)
      - ![화면 캡처 2022-08-31 173101](C:.\화면 캡처 2022-08-31 173101.png)
    - **Update 로직 작성**
      - ![화면 캡처 2022-08-31 173152](C:.\화면 캡처 2022-08-31 173152.png)

## 5. Admin site

- **Django의 가장 강력한 기능 중 하나**인 automatic admin interface
- 관리자 페이지
  - 사용자가 아닌 서버의 관리자가 활용하기 위한 페이지
  - 모델 class를 admin.py에 등록하고 관리
  - 레코드 생성 여부 확인에 매우 유용하며 직접 레코드를 삽입할 수 있다.
- **admin 계정 생성**
  - ![화면 캡처 2022-08-31 173352](C:.\화면 캡처 2022-08-31 173352.png)
- **admin site 로그인**
  - ![화면 캡처 2022-08-31 173442](C:.\화면 캡처 2022-08-31 173442.png)
- **admin에 모델 클래스 등록**
  - 모델의 record를 보기 위해서는 admin.py에 등록이 필요하다.
  - ![화면 캡처 2022-08-31 173536](C:.\화면 캡처 2022-08-31 173536.png)



![화면 캡처 2022-08-31 173641](C:.\화면 캡처 2022-08-31 173641.png)
