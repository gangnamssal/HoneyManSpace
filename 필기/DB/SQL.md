# SQL

---

## 1. Database

- **개요**
  - **파일을 이용한 데이터 관리**
    - **장점**
      - 운영체제에 관계 없이 어디에서나 쉽게 사용이 가능하다.
      - email이나 메신저를 이용해 간편하게 전송이 가능하다.
    - **단점**
      - 성능과 보안적 측면에서 한계가 명확하다.
      - 대용량 데이터를 다루기에 적합하지 않다.
      - 데이터를 구조적으로 정리하기에 어려움이 있다.
      - 확장이 불가능한 구조이다.
  - **스프레드 시트를 이용한 데이터 관리**
    - 스프레드 시트 (엑셀 시트)을 사용
    - 스프레드 시트는 컬럼(열)을 통해 데이터의 유형을 지정하고 레코드(행)을 통해 구체적인 데이터 값을 포함한다.
  - **데이터베이스를 이용한 데이터 관리**
    - 스프레드 시트와 달리 프로그래밍 언어를 사용해 작동 시킬 수 있다.
    - 가장 많이 쓰이는 유형은 RDB (Relational Database)라고 부르는 관계형 데이터베이스
    - RDB는 각각의 데이터를 테이블에 기입한다.



- **Database 정의**
  - 체계화된 데이터의 모임
  - 여러 사람이 공유하고 사용할 목적으로 통합 관리되는 정보의 집합
  - 검색, 구조화 같은 작업을 보다 쉽게 하기 위해 조직화된 데이터를 수집하는 저장 시스템
    - 내용을 고도로 구조화 함으로써 검색과 갱신의 효율화를 높인다.
    - 자료 항목의 중복을 없애고 구조화하여 기억시켜 놓은 자료의 집합체
  - DBMS (Database Management System)
    - Database를 조작하는 프로그램
    - Oracle, MySQL, SQLite 등
    - Database를 조작하기 위해 사용하는 언어를 **SQL**이라고 한다.
  - 웹 개발에서 대부분의 데이터베이스는 '관계형 데이터베이스 관리 시스템 (RDBMS)'을 사용하여 SQL로 데이터와 프로그래밍을 구성한다.



- **RDB**

  - Relational Database (관계형 데이터베이스)
  - 데이터를 테이블, 행, 열 등으로 나누어 구조화 하는 방식
  - 자료를 여러 테이블로 나누어서 관리, 이 테이블간 관계를 설정해 여러 데이터를 쉽게 조작할 수 있다는 장점이 있다.
  - SQL을 사용하여 데이터를 조회하고 조작
  - **스키마**
    - 테이블의 구조
    - 데이터베이스에서 자료의 구조, 표현 방법, 관계 등 전반적인 명세를 기술한 것
    - ![화면 캡처 2022-10-04 123815](C:.\화면 캡처 2022-10-04 123815.png)

  

  - **테이블**

    - 필드와 레코드를 사용해 조직된 데이터 요소들의 집합
    - 관계라고도 부른다.
    - ![화면 캡처 2022-10-04 123941](C:.\화면 캡처 2022-10-04 123941.png)

    - **필드**
      - 튜플 혹은 행(row)
      - 테이블의 데이터는 레코드에 저장된다.
    - **PK(Primary key)**
      - 기본 키
      - 각 레코드의 고유한 값
        - 각각의 데이터를 구분할 수 있는 고유의 값
      - 기술적으로 다른 항목과 절대로 중복될 수 없는 단일 값

  

  - **RDB의 이점**
    - 데이터를 직관적으로 표현할 수 있다.
    - 관련한 각 데이터에 쉽게 접근할 수 있다.
    - 대량의 데이터도 효율적으로 관리가 가능하다.

  - **RDBMS**
    - Relational Database Management System (관계형 데이터베이스 관리 시스템)
    - 관계형 데이터베이스를 만들고 업데이트하고 관리하는데 사용하는 프로그램
    - SQLite, MySQL, postgreSQL, Microsoft SQL Server, Oracle Database 등등

---

## 2. SQL

- **개요**
  - RDBMS의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어
  - RDBMS에서 데이터베이스 스키마를 생성 및 수정할 수 있으며, 데이블에서의 자료 검색 및 관리도 할 수 있다.
  - 데이터베이스 객체에 대한 처리를 관리하거나 접근 권한을 설정하여 허가된 사용자만 RDBMS를 관리할 수 있도록 할 수 있다.
  - 많은 데이터베이스 관련 프로그램들이 SQL을 표준으로 채택하고 있다.



- **SQL Commands**
  1. **DDL (Data Definition Language)**
  2. **DML (Data Manipulation Language)**
  3. **DCL (Data Control Language)**
  4. ![화면 캡처 2022-10-04 125254](C:.\화면 캡처 2022-10-04 125254.png)



- **SQL Syntax**
  - **모든 SQL 문(statement)은 SELECT, INSERT, UPDATE 등과 같은 키워드로 시작, 하나의 statement는 세미콜론(;)로 끝이 난다.**
    - 세미콜론은 각 SQL 문을 구분하는 표준 방법
  - SQL 키워드는 대소문자를 구분하지 않는다.
    - 하지만, SQL 문은 대문자로 작성하는 것을 권장한다.
  - **Statement (문)**
    - 독립적으로 실행할 수 있는 완전한 코드 조각
    - statement는 clause로 구성된다.
  - **Clause (절)**
    - statement의 하위 단위
  - ex)
    - ![화면 캡처 2022-10-04 125829](C:.\화면 캡처 2022-10-04 125829.png)

---

## 3. DDL (Data Definition Language)

- **사전 준비**
  1. bash 터미널에서 'mkdir 파일명' 을 통해 폴더를 생성 
     - 'cd 파일명'을 하여 폴더로 이동
  2. code~/.bashrc를 입력하여 .bashrc라는 파일 에디터창을 vscode로 오픈
     - .bashrc 내부에 alias sqlite3="winpty sqlite3"을 입력하고 저장
     - vscode 터미널을 열어 source~/.bashrc를 실행
  3. 데이터베이스 파일 생성
     - 'sqlite3 파일명.sqlite3' 을 입력하여 데이터베이스를 생성
     - 이미 파일이 존재한다면 동일한 명령어를 입력하여 실행
     - .mode column을 실행하여 컬럼 별로 볼 수 있게 설정
     - .header on을 실행하여 칼럼명을 같이 확인할 수 있게 설정
  4. DDL.sql 파일 생성
  5. DDL.sql 화면에서 마우스 우측 버튼을 눌러 Use Database 선택
  6. 데이터베이스 목록에서 생성한 파일 선택



- **Create Table**
  - 데이터베이스에 새 테이블을 만든다.
  - ![화면 캡처 2022-10-04 130315](C:.\화면 캡처 2022-10-04 130315.png)
  - **Query 실행하기**
    - 실행하고자 하는 명령문에 커서를 두고 마우스 우측 버튼
    - Run Selected Query 선택
    - 쿼리 실행 후 테이블 및 스키마 확인
      - id 컬럼은 직접 기본 키 역할의 컬럼을 정의하지 않으면 자동으로 **rowid** 컬럼이 만들짐.
      - **rowid**
        - 테이블의 행을 고유하게 식별하는 64비트 부호 있는 정수 값
        - 새 행을 삽입할 때마다 정수 값을 자동으로 할당
          - 1에서 시작
          - **테이블에서 가장 큰 rowid보다 하나 큰 다음 순차 정수를 자동으로 할당**
          - 만약 INTEGER PRIMARY KEY 키워드를 가진 컬럼을 직접 만들면 이 컬럼은 rowid 컬럼의 별칭(alias)이 된다.
            - 즉, 새 컬럼 이름으로 rowid에 액세스 할 수 있으며 rowid 이름으로도 여전히 액세스 가능하다.
          - **데이터가 최대 값에 도달하고 새 행을 삽입하려고 하면 SQLite는 사용되지 않는 정수를 찾아 사용한다.**
            - 만약 사용되지 않은 정수를 찾을 수 없으면 SQLITE_FULL 에러가 발생한다.
            - 일부 행을 삭제하고 새 행을 삽입하면 SQLite는 삭제된 행에서 rowid 값을 재사용하려고 시도한다.



- **SQLite Data Types**

  - **특징**
    - 데이터 타입을 지정하여 데이터 타입을 변환.
    - ![화면 캡처 2022-10-04 131919](C:.\화면 캡처 2022-10-04 131919.png)

  

  - **NULL**
    - NULL value
    - 정보가 없거나 알 수 없음을 의미한다.
    - **값이 따옴표 없이 NULL이면 사용**

  

  - **INTEGER**
    - 정수
    - 크기에 따라 0,1,2,3,4,6 또는 8바이트와 같은 가변 크기를 가진다.
    - **값에 둘러싸는 따옴표와 소수점 또는 지수가 없으면 사용**
    - SQLite에는 별도의 Boolean 타입이 없다.
    - 대신 Boolean 값은 정수 0과 1로 저장된다.

  

  - **REAL**
    - 실수
    - 8바이트 부동 소수점을 사용하는 10진수 값이 있는 실수
    - **값에 따옴표나 소수점, 지수가 없으면 사용**

  

  - **TEXT**
    - 문자 데이터
    - **값이 작은 따옴표나 큰 따옴표로 묶이면 사용**

  

  - **BLOB**
    - 입력된 그대로 저장된 데이터 덩어리 (대용 타입 없다.)
    - **바이너리** **등 멀티미디어 파일**
      - **Binary Data**
        - 데이터의 저장과 처리를 목적으로 0과 1의 이진 형식으로 인코딩 된 파일
        - 기본적으로 컴퓨터의 모든 데이터는 binary data
    - ex) 이미지 데이터

  

  - **'static, rigid typing' 데이터베이스**
    - statically, rigidly typed databases 라고도 부른다.
    - 저정되는 값의 데이터 타입은 컬럼에 선언된 데이터 타입에 의해 결정된다.
      - ex)
      - ![화면 캡처 2022-10-04 132225](C:.\화면 캡처 2022-10-04 132225.png)
      - a 컬럼에 '123', b 컬럼에 456 데이터를 삽입하는 경우 삽입 전 문자열 '123'을 정수 123으로 변환하고, 정수 456을 문자열 '456'으로 변환

  

  - **Type Affinity**
    - 타입 선호도
    - 특정 컬럼에 저장된 데이터에 권장되는 타입
    - 다른 데이터베이스 엔진 간의 호환성을 최대화
    - 정적이고 엄격한 타입을 사용하는 데이터베이스의 SQL문을  SQLite에서도 작동하도록 하기 위함이다.
    - ![화면 캡처 2022-10-04 132558](C:.\화면 캡처 2022-10-04 132558.png)



- **Constraints**

  - **개요**

    - 제약조건
    - 입력하는 자료에 대해 제약을 정한다.
    - 제약에 맞지 않다면 입력이 거부된다.
    - **사용자가 원하는 조건의 데이터만 유지하기 위한** 즉, **데이터의 무결성을 유지**하기 위한 보편적인 방법으로 테이블의 특정 컬럼에 설정하는 제약
      - **데이터 무결성**
        - 데이터베이스 내의 데이터에 대한 정확성, 일관성을 보장하기 위해 **데이터 변경 혹은 수정 시 여러 제한을 두어 데이터의 정확성을 보증**하는 것
        - 무결성이란 데이터의 정확성, 일관성을 나타낸다.
        - 데이터베이스에 저장된 데이터의 무결성을 보장하고 데이터베이스의 상태를 일관되게 유지하는 것이 목적이다.

  - **종류**

    1. **NOT NULL**
       - 컬럼이 NULL 값을 허용하지 않도록 지정
       - 기본적으로 테이블의 모든 컬럼은 NOT NULL 제약 조건을 명시적으로 사용하는 경우를 제외하고는 NULL  값을 허용한다.
    2. **UNIQUE**
       - 컬럼의 모든 값이 서로 구별되거나 고유한 값이 되도록 한다.
    3. **PRIMARY KEY**
       - 테이블에서 행의 고유성을 식별하는 데 사용되는 컬럼
       - 각 테이블에는 하나의 기본 키만 있다.
       - **암시적으로 NOT NULL 제약 조건이 포함되어 있다.**
       - ![화면 캡처 2022-10-04 133302](C:.\화면 캡처 2022-10-04 133302.png)
    4. **AUTOINCREMENT**
       - **사용되지 않는 값이나 이전에 삭제된 행의 값을 재사용하는 것을 방지**
       - INTEGER PRIMARY KEY 다음에 작성하면 해당 rowid를 다시 재사용하지 못하도록 한다.
       - ![화면 캡처 2022-10-04 133434](C:.\화면 캡처 2022-10-04 133434.png)
    5. **기타**
       1. **DEFAULT**
          - column 제약 조건 중 하나
          - 데이터를 추가할 때 값을 생략할 시에 기본 값을 설정한다.

    

- **ALTER TABLE**

  - **개요**
    - Modify the structure of an existing table
    - 기존 테이블의 구조를 수정(변경)
    - ![화면 캡처 2022-10-04 134532](C:.\화면 캡처 2022-10-04 134532.png)

  

  - **ALTER TABLE RENAME**
    - 테이블명 변경
      - ![화면 캡처 2022-10-04 134859](C:.\화면 캡처 2022-10-04 134859.png)

  

  - **ALTER TABLE RENAME COLUMN**
    - 컬럼명 변경
      - ![화면 캡처 2022-10-04 134936](C:.\화면 캡처 2022-10-04 134936.png)

  

  - **ALTER TABLE ADD COLUMN**
    - 새 컬럼 추가
      - ![화면 캡처 2022-10-04 135054](C:.\화면 캡처 2022-10-04 135054.png)
    - 만약 테이블에 기존 데이터가 있을 경우 다음과 같은 에러가 발생한다.
      - ![화면 캡처 2022-10-04 135159](C:.\화면 캡처 2022-10-04 135159.png)
    - **DEFAULT** 제약 조건을 사용하여 문제를 해결할 수 있다.
      - ![화면 캡처 2022-10-04 135344](C:.\화면 캡처 2022-10-04 135344.png)
      - address 컬럼이 추가되면서 기존에 있던 데이터들의 address 컬럼 값은 'no address'가 된다.
  - **ALTER TABLE DROP COLUMN**
    - 컬럼 삭제
      - ![화면 캡처 2022-10-04 135646](C:.\화면 캡처 2022-10-04 135646.png)
    - **삭제하지 못하는 경우**
      - 컬럼이 다른 부분에서 참조되는 경우
        - FOREIGN KEY (외래 키) 제약 조건에서 사용되는 경우
      - PRIMARY KEY인 경우
      - UNIQUE 제약 조건이 있는 경우
      - ![화면 캡처 2022-10-04 135808](C:.\화면 캡처 2022-10-04 135808.png)

  

- **DROP TABLE**

  - 데이터베이스에서 테이블을 제거한다.
    - ![화면 캡처 2022-10-04 140037](C:.\화면 캡처 2022-10-04 140037.png)
  - 존재하지 않는 테이블을 제거하면 SQLite에서 오류가 발생한다.
  - **한 번에 하나의 테이블만 삭제할 수 있다.**
    - 여러 테이블을 제거하려면 여러 DROP TABLE 문을 실행해야 한다.
  - **DROP TABLE 문은 실행 취소하거나 복구할 수 없다.**

---

## 4. DML (Data Manipulation Language)

- **시작하기**
  1. **시작하기**
     - ![화면 캡처 2022-10-04 141032](C:.\화면 캡처 2022-10-04 141032.png)
  2. **데이터베이스 파일 열기**
     - ![화면 캡처 2022-10-04 141154](C:.\화면 캡처 2022-10-04 141154.png)
  3. **종료하기**
     - ![화면 캡처 2022-10-04 141401](C:.\화면 캡처 2022-10-04 141401.png)
  4. **csv 파일을 SQLite 테이블로 가져오기**
     1. **DML.sql 파일 생성**
     2. **테이블 생성하기**
        - ![화면 캡처 2022-10-04 141534](C:.\화면 캡처 2022-10-04 141534.png)
     3. **데이터베이스 파일 열기**
        - ![화면 캡처 2022-10-04 141642](C:.\화면 캡처 2022-10-04 141642.png)
     4. **모드(.mode)를 csv로 설정**
        - ![화면 캡처 2022-10-04 141708](C:.\화면 캡처 2022-10-04 141708.png)
     5. **.import 명령어를 사용하여 csv 데이터를 테이블로 가져오기**
        - ![화면 캡처 2022-10-04 141731](C:.\화면 캡처 2022-10-04 141731.png)
     6. **import 된 데이터 확인하기**



- **Simple query**
  - ![화면 캡처 2022-10-04 142652](C:.\화면 캡처 2022-10-04 142652.png)
    - 특정 테이블에서 데이터를 조회하기 위해 사용
    - **전체 데이터 조회하기**
      - ![화면 캡처 2022-10-04 142914](C:.\화면 캡처 2022-10-04 142914.png)
    - **rowid 컬럼 조회**
      - ![화면 캡처 2022-10-04 143007](C:.\화면 캡처 2022-10-04 143007.png)
    - **문법 규칙**
      - SELECT 절에서 컬럼 또는 쉼표로 구분된 컬럼 목록을 지정
      - FROM 절에서 데이터를 가져올 테이블을 지정



- **Sorting rows**

  - ![화면 캡처 2022-10-04 143044](C:.\화면 캡처 2022-10-04 143044.png)

    - **SELECT 문에 추가하여 결과를 정렬**
    - **ORDER BY 절은 FROM 절 뒤에 위치**
    - 하나 이상의 컬럼을 기준으로 오름차순, 내림차순으로 정렬할 수 있다.
      - **ASC : 오름차순 (기본 값)**
      - **DESC : 내림차순**

    

  - **Sorting NULLs**

    - NULL의 정렬 방식
    - 정렬과 관련하여 SQLite는 **NULL을 다른 값보다 작은 것으로 간주**한다.
    - **즉, ASC를 사용하는 경우 결과의 시작 부분에 NULL이 표시되고, DESC를 사용하는 경우 결과의 끝에 NULL이 표시된다.**



- **Filtering data**

  - **DISTINCT**

    - ![화면 캡처 2022-10-04 143509](C:.\화면 캡처 2022-10-04 143509.png)
    - **조회 결과에서 중복된 행을 제거**
    - DISTINCT 절은 SELECT 에서 선택적으로 사용할 수 있는 절
    - **문법 규칙**
    - DISTINCT 절은 SELECT 키워드 바로 뒤에 나타나야 한다.
    - DISTINCT 키워드 뒤에 컬럼 또는 컬럼 목록을 작성한다.

    

    - **NULL with DISTINCT**
      - SQLite는 NULL 값을 중복으로 간주한다.
      - **NULL 값이 있는 컬럼에 DISTINCT 절을 사용하면 SQLite는 NULL 값의 한 행을 유지한다.**

  

  

  - **WHERE**

    - ![화면 캡처 2022-10-04 143819](C:.\화면 캡처 2022-10-04 143819.png)
    - **조회 시 특정 검색 조건을 지정**
    - **WHERE 절은 SELECT 문에서 선택적으로 사용할 수 있는 절이다.**
      - SELECT 문 외에도 UPDATE 및 DELETE 문에서 WHERE 절을 사용할 수 있다.
    -  **FROM 절 뒤에 작성**
    - **작성 예시**
      - ![화면 캡처 2022-10-04 144112](C:.\화면 캡처 2022-10-04 144112.png)
    - **SQLite 비교 연산자**
      - =
      - <> or !=
      - <, >
      - <= , >=

    

    - **SQLite 논리 연산자**

      - 일부 표현식의 truth를 테스트할 수 있다.

      - 1,0 또는 NULL 값을 반환

      - ALL, AND, ANY, BETWEEN, IN, LIKE, NOT, OR 등

        - **LIKE**
          - **패턴 일치를 기반으로 데이터를 조회**
          - SELECT, DELETE, UPDATE 문의 WHERE 절에서 사용
          - **기본적으로 대소문자를 구분하지 않음**
            - ex) 'A' LIKE 'a' = true
          - SQLite는 패턴 구성을 위한 두 개의 와일드카드를 제공한다.
            1. **% (percent)**
               - **0개 이상의 문자가 올 수 있음을 의미**
               - ex)
                 - '영%' 패턴은 영으로 시작하는 모든 문자열과 일치 (영, 영미..)
                 - '%도' 패턴은 도로 끝나는 모든 문자열과 일치 (도, 수도..)
                 - '%강원%' 패턴은 강원을 포함하는 모든 문자열과 일치(강원, 강원도, 강원도에 살아요 등등)
            2.  **_ (underscore)**
               - **단일 (1개) 문자가 있음을 의미**
               - ex)
                 - '영_' 패턴은 영으로 시작하고 총 2자리인 문자열과 일치 (영미, 영수, 영호 등)
                 - '_도' 패턴은 도로 끝나고 총 2자리인 문자열과 일치 (수도, 과도 등)
            3. **종합 예시**
               - ![화면 캡처 2022-10-04 145134](C:.\화면 캡처 2022-10-04 145134.png)
          - ![화면 캡처 2022-10-04 145724](C:.\화면 캡처 2022-10-04 145724.png)

        

        - **IN**
          - **값이 값 목록 결과에 있는 값과 일치하는지 확인**, 여부에 따라 true or false를 반환
          - **IN 연산자의 결과를 부정하려면 NOT IN 연산자를 사용**
          - ![화면 캡처 2022-10-04 145807](C:.\화면 캡처 2022-10-04 145807.png)

        

        - **BETWEEN**
          - **값이 값 범위에 있는지 테스트**
          - 값이 지정된 범위에 있으면 true를 반환
          - **SELECT, DELETE 및 UPDATE 문의 WHERE 절에서 사용할 수 있음**
          - **BETWEEN 연산자의 결과를 부정하려면 NOT BETWEEN 연산자 사용**
          - ![화면 캡처 2022-10-04 145840](C:.\화면 캡처 2022-10-04 145840.png)

        

  - **LIMIT**

    - ![화면 캡처 2022-10-04 145908](C:.\화면 캡처 2022-10-04 145908.png)
    - **쿼리에서 반환되는 행 수를 제한**
    - SELECT 문에서 선택적으로 사용할 수 있는 절
    - row_count는 반환되는 행 수를 지정하는 양의 정수를 의미
    - **OFFSET**
      - LIMIT 절을 사용하면 첫 번째 데이터부터 지정한 수 만큼의 데이터를 받아올 수 있지만, **OFFSET과 함께 사용하면 특정 위치에서부터 데이터를 조회**할 수 있다.
      - ![화면 캡처 2022-10-04 150222](C:.\화면 캡처 2022-10-04 150222.png)



- **Grouping data**
  - **GROUP BY**
    - ![화면 캡처 2022-10-04 150404](C:.\화면 캡처 2022-10-04 150404.png)
    - **특정 그룹으로 묶인 결과를 생성**
    - 선택된 컬럼 값을 기준으로 데이터(행) 들의 공통 값을 묶어서 결과로 나타낸다.
    - **SELECT 문에서 선택적으로 사용가능한 절**
    - SELECT 문의 FROM 절 뒤에 작성
      - **WHERE 절이 포함된 경우 WHERE 절 뒤에 작성해야 한다.**
    - **각 그룹에 대해 MIN, MAX, SUM, COUNT, AVG와 같은 집계 함수를 적용하여 각 그룹에 대한 추가적인 정보를 제공할 수 있다.**
      - **Aggregate function**
        - 집계 함수
        - ![화면 캡처 2022-10-04 151114](C:.\화면 캡처 2022-10-04 151114.png)
      - **AS 키워드를 사용해 컬럼명을 임시로 변경하여 조회할 수 있다.**
        - ![화면 캡처 2022-10-04 162409](C:.\화면 캡처 2022-10-04 162409.png)



- **Changing data**

  - **INSERT**
    - ![화면 캡처 2022-10-04 151401](C:.\화면 캡처 2022-10-04 151401.png)
    - **새 행을 테이블에 삽입**
    - **문법 규칙**
      1. 먼저 INSERT INTO 키워드 뒤에 데이터를 **삽입할 테이블의 이름을 지정**
      2. 테이블 이름 뒤에 쉼표로 구분된 컬럼 목록을 추가
         - 컬럼 목록은 선택 사항이지만 컬럼 목록을 포함하는 것이 권장
      3. VALUES 키워드 뒤에 쉼표로 구분된 값 목록을 추가
         - **만약 컬럼 목록을 생략하는 경우 값 목록의 모든 컬럼에 대한 값을 지정해야 한다.**
         - 값 목록의 값 개수는 컬럼 목록의 컬럼 개수와 같아야 한다.
    - ![화면 캡처 2022-10-04 151709](C:.\화면 캡처 2022-10-04 151709.png)
    - ![화면 캡처 2022-10-04 151733](C:.\화면 캡처 2022-10-04 151733.png)
    - ![화면 캡처 2022-10-04 151828](C:.\화면 캡처 2022-10-04 151828.png)

  

  - **UPDATE**
    - ![화면 캡처 2022-10-04 151942](C:.\화면 캡처 2022-10-04 151942.png)
    - **테이블에 있는 기존 행의 데이터를 업데이트 한다.**
    - **문법 규칙**
      1. UPDATE 절 이후에 업데이트 할 테이블을 지정
      2. SET 절에서 테이블의 각 컬럼에 대해 새 값을 설정
      3. WHERE 절의 조건을 사용하여 업데이트할 행을 지정
         - WHERE 절은 선택 사항이며, 생략하면 UPDATE 문은 테이블의 모든 행에 있는 데이터를 업데이트 한다.
      4. 선택적으로 ORDER BY 및 LIMIT 절을 사용하여 업데이트할 행 수를 지정 할 수도 있다.
  - **DELETE**
    - ![화면 캡처 2022-10-04 153240](C:.\화면 캡처 2022-10-04 153240.png)
    - **테이블에서 행을 제거**
    - 테이블의 한 행, 여러 행 및 모든 행을 삭제할 수 있다.
    - **문법 규칙**
      1. DELETE FROM 키워드 뒤에 행을 제거하려는 테이블의 이름을 지정
      2. WHERE 절에 검색 조건을 추가하여 제거할 행을 식별
         - WHERE 절은 선택 사항이며, 생략하면 DELETE 문은 테이블의 모든 행을 삭제
      3. 선택적으로 ORDER BY 및 LIMIT 절을 사용하여 삭제할 행 수를 지정 할 수도 있다.